{"packages":{"cern.jet.stat":{"classes":{"Probability":{"methods":{"studentTInverse":{"return-type":"double","signature":"(double, int)","comment-text":"Returns the value, <tt>t<\/tt>, for which the area under the\n Student-t probability density function (integrated from\n minus infinity to <tt>t<\/tt>) is equal to <tt>1-alpha\/2<\/tt>.\n The value returned corresponds to usual Student t-distribution lookup\n table for <tt>t<sub>alpha[size]<\/sub><\/tt>.\n <p>\n The function uses the studentT function to determine the return\n value iteratively.","lines":{},"747":"\t\t}","746":"\t\t   return x3;","745":"\t\t   \/\/ We found a perfect value -> return","744":"\t\tif (Math.abs(f3)<1e-8) { \/\/ This criteria needs to be very tight!","751":"\t\t   x2=x3; f2=f3;","750":"\t\t   x1=x2; f1=f2;","749":"\t\tif (f3*f2<0) {","748":"","739":"\t\ts12 = (f2-f1)\/(x2-x1);","738":"\t\t\/\/ Calculate slope of secant and t value for which it is 0.","737":"\t do {","736":"\t \/\/ Pegasus-method","743":"\t\tf3 = studentT(size,x3)-cumProb;","742":"\t\t\/\/ Calculate function value at x3","line-start":709,"741":"","740":"\t\tx3 = x2 - f2\/s12;","762":"\t\treturn x1;","763":"\t }","760":"\t\treturn x2;","761":"\t } else {","764":"}","765":"}","754":"\t\t   f1=g*f1;","755":"\t\t   x2=x3; f2=f3;","752":"\t\t} else {","753":"\t\t   g = f2\/(f2+f3);","758":"","modifiers":"public static","759":"\t if (Math.abs(f2)<=Math.abs(f1)) {","756":"\t\t}","757":"\t } while(Math.abs(x2-x1)>0.001);","tags":{"@param":{"text":"size size of data set","kind":"@param"}},"713":"\t double g,s12;","712":"\t double x1,x2,x3;","715":"\t cumProb = 1-alpha\/2; \/\/ Cumulative probability","714":"","717":"","716":"\t x1 = normalInverse(cumProb);","719":"\t if (size > 200) {","718":"\t \/\/ Return inverse of normal for large size","709":"public static double studentTInverse(double alpha, int size) {","711":"\t double f1,f2,f3;","710":"\t double cumProb = 1-alpha\/2; \/\/ Cumulative probability","728":"\t\t   x2 = x2\/2;","729":"\t\t} else {","730":"\t\t   x2 = x2+x1;","731":"\t\t}","source":"public static double studentTInverse(double alpha, int size) {\n\t double cumProb = 1-alpha\/2; \/\/ Cumulative probability\n\t double f1,f2,f3;\n\t double x1,x2,x3;\n\t double g,s12;\n\n\t cumProb = 1-alpha\/2; \/\/ Cumulative probability\n\t x1 = normalInverse(cumProb);\n\n\t \/\/ Return inverse of normal for large size\n\t if (size > 200) {\n\t\treturn x1;\n\t }\n\n\t \/\/ Find a pair of x1,x2 that braket zero\n\t f1 = studentT(size,x1)-cumProb;\n\t x2 = x1; f2 = f1;\n\t do {\n\t\tif (f1>0) {\n\t\t   x2 = x2\/2;\n\t\t} else {\n\t\t   x2 = x2+x1;\n\t\t}\n\t\tf2 = studentT(size,x2)-cumProb;\n\t } while (f1*f2>0);\n\n\t \/\/ Find better approximation\n\t \/\/ Pegasus-method\n\t do {\n\t\t\/\/ Calculate slope of secant and t value for which it is 0.\n\t\ts12 = (f2-f1)\/(x2-x1);\n\t\tx3 = x2 - f2\/s12;\n\n\t\t\/\/ Calculate function value at x3\n\t\tf3 = studentT(size,x3)-cumProb;\n\t\tif (Math.abs(f3)<1e-8) { \/\/ This criteria needs to be very tight!\n\t\t   \/\/ We found a perfect value -> return\n\t\t   return x3;\n\t\t}\n\n\t\tif (f3*f2<0) {\n\t\t   x1=x2; f1=f2;\n\t\t   x2=x3; f2=f3;\n\t\t} else {\n\t\t   g = f2\/(f2+f3);\n\t\t   f1=g*f1;\n\t\t   x2=x3; f2=f3;\n\t\t}\n\t } while(Math.abs(x2-x1)>0.001);\n\n\t if (Math.abs(f2)<=Math.abs(f1)) {\n\t\treturn x2;\n\t } else {\n\t\treturn x1;\n\t }\n}\n}\n","732":"\t\tf2 = studentT(size,x2)-cumProb;","733":"\t } while (f1*f2>0);","734":"","735":"\t \/\/ Find better approximation","720":"\t\treturn x1;","721":"\t }","722":"","723":"\t \/\/ Find a pair of x1,x2 that braket zero","qualified-name":"cern.jet.stat.Probability.studentTInverse","724":"\t f1 = studentT(size,x1)-cumProb;","725":"\t x2 = x1; f2 = f1;","flat-signature":"(double, int)","raw-comment-text":" Returns the value, <tt>t<\/tt>, for which the area under the\n Student-t probability density function (integrated from\n minus infinity to <tt>t<\/tt>) is equal to <tt>1-alpha\/2<\/tt>.\n The value returned corresponds to usual Student t-distribution lookup\n table for <tt>t<sub>alpha[size]<\/sub><\/tt>.\n <p>\n The function uses the studentT function to determine the return\n value iteratively.\n\n @param alpha probability\n @param size size of data set\n","726":"\t do {","727":"\t\tif (f1>0) {"},"chiSquare":{"tags":{"@param":{"text":"x integration end point.","kind":"@param"}},"source":"static public double chiSquare(double v, double x) throws ArithmeticException { \n\tif( x < 0.0 || v < 1.0 ) return 0.0;\n\treturn Gamma.incompleteGamma( v\/2.0, x\/2.0 );\n}\n","comment-text":"Returns the area under the left hand tail (from 0 to <tt>x<\/tt>)\n of the Chi square probability density function with\n <tt>v<\/tt> degrees of freedom.\n <pre>\n                                  inf.\n                                    -\n                        1          | |  v\/2-1  -t\/2\n  P( x | v )   =   -----------     |   t      e     dt\n                    v\/2  -       | |\n                   2    | (v\/2)   -\n                                   x\n <\/pre>\n where <tt>x<\/tt> is the Chi-square variable.\n <p>\n The incomplete gamma integral is used, according to the\n formula\n <p>\n <tt>y = chiSquare( v, x ) = incompleteGamma( v\/2.0, x\/2.0 )<\/tt>.\n <p>\n The arguments must both be positive.","line-end":226,"lines":{"222":"static public double chiSquare(double v, double x) throws ArithmeticException { ","223":"\tif( x < 0.0 || v < 1.0 ) return 0.0;","225":"}","224":"\treturn Gamma.incompleteGamma( v\/2.0, x\/2.0 );"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.chiSquare","modifiers":"public static","flat-signature":"(double, double)","line-start":222,"signature":"(double, double)","raw-comment-text":" Returns the area under the left hand tail (from 0 to <tt>x<\/tt>)\n of the Chi square probability density function with\n <tt>v<\/tt> degrees of freedom.\n <pre>\n                                  inf.\n                                    -\n                        1          | |  v\/2-1  -t\/2\n  P( x | v )   =   -----------     |   t      e     dt\n                    v\/2  -       | |\n                   2    | (v\/2)   -\n                                   x\n <\/pre>\n where <tt>x<\/tt> is the Chi-square variable.\n <p>\n The incomplete gamma integral is used, according to the\n formula\n <p>\n <tt>y = chiSquare( v, x ) = incompleteGamma( v\/2.0, x\/2.0 )<\/tt>.\n <p>\n The arguments must both be positive.\n\n @param v degrees of freedom.\n @param x integration end point.\n"},"binomial":{"tags":{"@param":{"text":"p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).","kind":"@param"}},"source":"static public double binomial(int k, int n, double p) {\n\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();\n\tif( (k < 0) || (n < k) ) throw new IllegalArgumentException();\n\n\tif( k == n ) return( 1.0 );\n\tif( k == 0 ) return Math.pow( 1.0-p, n-k );\n\t\n\treturn Gamma.incompleteBeta( n-k, k+1, 1.0 - p );\n}\n","comment-text":"Returns the sum of the terms <tt>0<\/tt> through <tt>k<\/tt> of the Binomial\n probability density.\n <pre>\n   k\n   --  ( n )   j      n-j\n   >   (   )  p  (1-p)\n   --  ( j )\n  j=0\n <\/pre>\n The terms are not summed directly; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n <tt>y = binomial( k, n, p ) = Gamma.incompleteBeta( n-k, k+1, 1-p )<\/tt>.\n <p>\n All arguments must be positive,","line-end":168,"lines":{"159":"static public double binomial(int k, int n, double p) {","163":"\tif( k == n ) return( 1.0 );","162":"","161":"\tif( (k < 0) || (n < k) ) throw new IllegalArgumentException();","160":"\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();","167":"}","166":"\treturn Gamma.incompleteBeta( n-k, k+1, 1.0 - p );","165":"\t","164":"\tif( k == 0 ) return Math.pow( 1.0-p, n-k );"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.binomial","modifiers":"public static","flat-signature":"(int, int, double)","line-start":159,"signature":"(int, int, double)","raw-comment-text":" Returns the sum of the terms <tt>0<\/tt> through <tt>k<\/tt> of the Binomial\n probability density.\n <pre>\n   k\n   --  ( n )   j      n-j\n   >   (   )  p  (1-p)\n   --  ( j )\n  j=0\n <\/pre>\n The terms are not summed directly; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n <tt>y = binomial( k, n, p ) = Gamma.incompleteBeta( n-k, k+1, 1-p )<\/tt>.\n <p>\n All arguments must be positive, \n @param k end term.\n @param n the number of trials.\n @param p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).\n"},"binomialComplemented":{"tags":{"@param":{"text":"p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).","kind":"@param"}},"source":"static public double binomialComplemented(int k, int n, double p) {\n\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();\n\tif( (k < 0) || (n < k) ) throw new IllegalArgumentException();\n\n\tif( k == n ) return( 0.0 );\n\tif( k == 0 ) return 1.0 - Math.pow( 1.0-p, n-k );\n\t\n\treturn Gamma.incompleteBeta( k+1, n-k, p );\n}\n","comment-text":"Returns the sum of the terms <tt>k+1<\/tt> through <tt>n<\/tt> of the Binomial\n probability density.\n <pre>\n   n\n   --  ( n )   j      n-j\n   >   (   )  p  (1-p)\n   --  ( j )\n  j=k+1\n <\/pre>\n The terms are not summed directly; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n <tt>y = binomialComplemented( k, n, p ) = Gamma.incompleteBeta( k+1, n-k, p )<\/tt>.\n <p>\n All arguments must be positive,","line-end":197,"lines":{"190":"\tif( (k < 0) || (n < k) ) throw new IllegalArgumentException();","191":"","188":"static public double binomialComplemented(int k, int n, double p) {","189":"\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();","196":"}","193":"\tif( k == 0 ) return 1.0 - Math.pow( 1.0-p, n-k );","192":"\tif( k == n ) return( 0.0 );","195":"\treturn Gamma.incompleteBeta( k+1, n-k, p );","194":"\t"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.binomialComplemented","modifiers":"public static","flat-signature":"(int, int, double)","line-start":188,"signature":"(int, int, double)","raw-comment-text":" Returns the sum of the terms <tt>k+1<\/tt> through <tt>n<\/tt> of the Binomial\n probability density.\n <pre>\n   n\n   --  ( n )   j      n-j\n   >   (   )  p  (1-p)\n   --  ( j )\n  j=k+1\n <\/pre>\n The terms are not summed directly; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n <tt>y = binomialComplemented( k, n, p ) = Gamma.incompleteBeta( k+1, n-k, p )<\/tt>.\n <p>\n All arguments must be positive, \n @param k end term.\n @param n the number of trials.\n @param p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).\n"},"normal":{"tags":{"@param":{"text":"x the integration limit.","kind":"@param"}},"source":"static public double normal(double mean, double variance, double x) throws ArithmeticException {\n\tif (x>0) \n\t\treturn 0.5 + 0.5*errorFunction((x-mean)\/Math.sqrt(2.0*variance));\n\telse \n\t\treturn 0.5 - 0.5*errorFunction((-(x-mean))\/Math.sqrt(2.0*variance));\n}\n\/**\n","comment-text":"Returns the area under the Normal (Gaussian) probability density\n function, integrated from minus infinity to <tt>x<\/tt>.\n <pre>\n                            x\n                             -\n                   1        | |                 2\n  normal(x)  = ---------    |    exp( - (t-mean) \/ 2v ) dt\n               sqrt(2pi*v)| |\n                           -\n                          -inf.\n\n <\/pre>\n where <tt>v = variance<\/tt>.\n Computation is via the functions <tt>errorFunction<\/tt>.","line-end":561,"lines":{"560":"\/**","558":"\t\treturn 0.5 - 0.5*errorFunction((-(x-mean))\/Math.sqrt(2.0*variance));","559":"}","556":"\t\treturn 0.5 + 0.5*errorFunction((x-mean)\/Math.sqrt(2.0*variance));","557":"\telse ","554":"static public double normal(double mean, double variance, double x) throws ArithmeticException {","555":"\tif (x>0) "},"return-type":"double","qualified-name":"cern.jet.stat.Probability.normal","modifiers":"public static","flat-signature":"(double, double, double)","line-start":554,"signature":"(double, double, double)","raw-comment-text":" Returns the area under the Normal (Gaussian) probability density\n function, integrated from minus infinity to <tt>x<\/tt>.\n <pre>\n                            x\n                             -\n                   1        | |                 2\n  normal(x)  = ---------    |    exp( - (t-mean) \/ 2v ) dt\n               sqrt(2pi*v)| |\n                           -\n                          -inf.\n\n <\/pre>\n where <tt>v = variance<\/tt>.\n Computation is via the functions <tt>errorFunction<\/tt>.\n\n @param mean the mean of the normal distribution.\n @param variance the variance of the normal distribution.\n @param x the integration limit.\n"},"negativeBinomial":{"tags":{"@param":{"text":"p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).","kind":"@param"}},"source":"static public double negativeBinomial(int k, int n, double p) {\n\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();\n\tif(k < 0) return 0.0;\n\n\treturn Gamma.incompleteBeta( n, k+1, p );\n}\n","comment-text":"Returns the sum of the terms <tt>0<\/tt> through <tt>k<\/tt> of the Negative Binomial Distribution.\n <pre>\n   k\n   --  ( n+j-1 )   n      j\n   >   (       )  p  (1-p)\n   --  (   j   )\n  j=0\n <\/pre>\n In a sequence of Bernoulli trials, this is the probability\n that <tt>k<\/tt> or fewer failures precede the <tt>n<\/tt>-th success.\n <p>\n The terms are not computed individually; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n <tt>y = negativeBinomial( k, n, p ) = Gamma.incompleteBeta( n, k+1, p )<\/tt>.\n\n All arguments must be positive,","line-end":476,"lines":{"474":"\treturn Gamma.incompleteBeta( n, k+1, p );","475":"}","472":"\tif(k < 0) return 0.0;","473":"","470":"static public double negativeBinomial(int k, int n, double p) {","471":"\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.negativeBinomial","modifiers":"public static","flat-signature":"(int, int, double)","line-start":470,"signature":"(int, int, double)","raw-comment-text":" Returns the sum of the terms <tt>0<\/tt> through <tt>k<\/tt> of the Negative Binomial Distribution.\n <pre>\n   k\n   --  ( n+j-1 )   n      j\n   >   (       )  p  (1-p)\n   --  (   j   )\n  j=0\n <\/pre>\n In a sequence of Bernoulli trials, this is the probability\n that <tt>k<\/tt> or fewer failures precede the <tt>n<\/tt>-th success.\n <p>\n The terms are not computed individually; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n <tt>y = negativeBinomial( k, n, p ) = Gamma.incompleteBeta( n, k+1, p )<\/tt>.\n\n All arguments must be positive, \n @param k end term.\n @param n the number of trials.\n @param p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).\n"},"studentT":{"tags":{"@param":{"text":"t integration end point.","kind":"@param"}},"source":"static public double studentT(double k, double t) throws ArithmeticException { \n\tif( k <= 0 ) throw new IllegalArgumentException();\n\tif( t == 0 ) return( 0.5 );\n\t\n\tdouble cdf = 0.5 * Gamma.incompleteBeta( 0.5*k, 0.5, k \/ (k + t * t) );\n\t\n\tif (t >= 0) cdf = 1.0 - cdf; \/\/ fixes bug reported by stefan.bentink@molgen.mpg.de\n\t \n\treturn cdf;\n}\n","comment-text":"Returns the integral from minus infinity to <tt>t<\/tt> of the Student-t \n distribution with <tt>k &gt; 0<\/tt> degrees of freedom.\n <pre>\n                                      t\n                                      -\n                                     | |\n              -                      |         2   -(k+1)\/2\n             | ( (k+1)\/2 )           |  (     x   )\n       ----------------------        |  ( 1 + --- )        dx\n                     -               |  (      k  )\n       sqrt( k pi ) | ( k\/2 )        |\n                                   | |\n                                    -\n                                   -inf.\n <\/pre>\n Relation to incomplete beta integral:\n <p>\n <tt>1 - studentT(k,t) = 0.5 * Gamma.incompleteBeta( k\/2, 1\/2, z )<\/tt>\n where <tt>z = k\/(k + t**2)<\/tt>.\n <p>\n Since the function is symmetric about <tt>t=0<\/tt>, the area under the\n right tail of the density is found by calling the function\n with <tt>-t<\/tt> instead of <tt>t<\/tt>.","line-end":696,"lines":{"687":"\tif( k <= 0 ) throw new IllegalArgumentException();","686":"static public double studentT(double k, double t) throws ArithmeticException { ","694":"\treturn cdf;","695":"}","692":"\tif (t >= 0) cdf = 1.0 - cdf; \/\/ fixes bug reported by stefan.bentink@molgen.mpg.de","693":"\t ","690":"\tdouble cdf = 0.5 * Gamma.incompleteBeta( 0.5*k, 0.5, k \/ (k + t * t) );","691":"\t","688":"\tif( t == 0 ) return( 0.5 );","689":"\t"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.studentT","modifiers":"public static","flat-signature":"(double, double)","line-start":686,"signature":"(double, double)","raw-comment-text":" Returns the integral from minus infinity to <tt>t<\/tt> of the Student-t \n distribution with <tt>k &gt; 0<\/tt> degrees of freedom.\n <pre>\n                                      t\n                                      -\n                                     | |\n              -                      |         2   -(k+1)\/2\n             | ( (k+1)\/2 )           |  (     x   )\n       ----------------------        |  ( 1 + --- )        dx\n                     -               |  (      k  )\n       sqrt( k pi ) | ( k\/2 )        |\n                                   | |\n                                    -\n                                   -inf.\n <\/pre>\n Relation to incomplete beta integral:\n <p>\n <tt>1 - studentT(k,t) = 0.5 * Gamma.incompleteBeta( k\/2, 1\/2, z )<\/tt>\n where <tt>z = k\/(k + t**2)<\/tt>.\n <p>\n Since the function is symmetric about <tt>t=0<\/tt>, the area under the\n right tail of the density is found by calling the function\n with <tt>-t<\/tt> instead of <tt>t<\/tt>.\n\n @param k degrees of freedom.\n @param t integration end point.\n"},"beta":{"tags":{},"source":"static public double beta(double a, double b, double x ) {\n\treturn Gamma.incompleteBeta( a, b, x );\n}\n","comment-text":"Returns the area from zero to <tt>x<\/tt> under the beta density\n function.\n <pre>\n                          x\n            -             -\n           | (a+b)       | |  a-1      b-1\n P(x)  =  ----------     |   t    (1-t)    dt\n           -     -     | |\n          | (a) | (b)   -\n                         0\n <\/pre>\n This function is identical to the incomplete beta\n integral function <tt>Gamma.incompleteBeta(a, b, x)<\/tt>.\n\n The complemented function is\n\n <tt>1 - P(1-x)  =  Gamma.incompleteBeta( b, a, x )<\/tt>;","line-end":129,"lines":{"127":"\treturn Gamma.incompleteBeta( a, b, x );","128":"}","126":"static public double beta(double a, double b, double x ) {"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.beta","modifiers":"public static","flat-signature":"(double, double, double)","line-start":126,"signature":"(double, double, double)","raw-comment-text":" Returns the area from zero to <tt>x<\/tt> under the beta density\n function.\n <pre>\n                          x\n            -             -\n           | (a+b)       | |  a-1      b-1\n P(x)  =  ----------     |   t    (1-t)    dt\n           -     -     | |\n          | (a) | (b)   -\n                         0\n <\/pre>\n This function is identical to the incomplete beta\n integral function <tt>Gamma.incompleteBeta(a, b, x)<\/tt>.\n\n The complemented function is\n\n <tt>1 - P(1-x)  =  Gamma.incompleteBeta( b, a, x )<\/tt>;\n\n"},"betaComplemented":{"tags":{},"source":"static public double betaComplemented(double a, double b, double x ) {\n\treturn Gamma.incompleteBeta( b, a, x );\n}\n","comment-text":"Returns the area under the right hand tail (from <tt>x<\/tt> to\n infinity) of the beta density function.\n \n This function is identical to the incomplete beta\n integral function <tt>Gamma.incompleteBeta(b, a, x)<\/tt>.","line-end":139,"lines":{"137":"\treturn Gamma.incompleteBeta( b, a, x );","136":"static public double betaComplemented(double a, double b, double x ) {","138":"}"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.betaComplemented","modifiers":"public static","flat-signature":"(double, double, double)","line-start":136,"signature":"(double, double, double)","raw-comment-text":" Returns the area under the right hand tail (from <tt>x<\/tt> to\n infinity) of the beta density function.\n \n This function is identical to the incomplete beta\n integral function <tt>Gamma.incompleteBeta(b, a, x)<\/tt>.\n"},"gammaComplemented":{"tags":{"@param":{"text":"x integration end point.","kind":"@param"}},"source":"static public double gammaComplemented(double a, double b, double x ) {\n\tif( x < 0.0 ) return 0.0;\n\treturn Gamma.incompleteGammaComplement(b, a*x);\n}\n","comment-text":"Returns the integral from <tt>x<\/tt> to infinity of the gamma\n probability density function:\n <pre>\n               inf.\n        b       -\n       a       | |   b-1  -at\n y =  -----    |    t    e    dt\n       -     | |\n      | (b)   -\n               x\n <\/pre>\n The incomplete gamma integral is used, according to the\n relation\n <p>\n y = Gamma.incompleteGammaComplement( b, a*x ).","line-end":448,"lines":{"444":"static public double gammaComplemented(double a, double b, double x ) {","445":"\tif( x < 0.0 ) return 0.0;","446":"\treturn Gamma.incompleteGammaComplement(b, a*x);","447":"}"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.gammaComplemented","modifiers":"public static","flat-signature":"(double, double, double)","line-start":444,"signature":"(double, double, double)","raw-comment-text":" Returns the integral from <tt>x<\/tt> to infinity of the gamma\n probability density function:\n <pre>\n               inf.\n        b       -\n       a       | |   b-1  -at\n y =  -----    |    t    e    dt\n       -     | |\n      | (b)   -\n               x\n <\/pre>\n The incomplete gamma integral is used, according to the\n relation\n <p>\n y = Gamma.incompleteGammaComplement( b, a*x ).\n\n @param a the paramater a (alpha) of the gamma distribution.\n @param b the paramater b (beta, lambda) of the gamma distribution.\n @param x integration end point.\n"},"errorFunction":{"tags":{"@param":{"text":"a the argument to the function.","kind":"@param"}},"source":"static public double errorFunction(double x) throws ArithmeticException { \n\tdouble y, z;\n\tfinal double T[] = {\n\t\t\t\t\t 9.60497373987051638749E0,\n\t\t\t\t\t 9.00260197203842689217E1,\n\t\t\t\t\t 2.23200534594684319226E3,\n\t\t\t\t\t 7.00332514112805075473E3,\n\t\t\t\t\t 5.55923013010394962768E4\n\t\t\t\t\t};\n\tfinal double U[] = {\n\t\t\t\t   \/\/1.00000000000000000000E0,\n\t\t\t\t\t 3.35617141647503099647E1,\n\t\t\t\t\t 5.21357949780152679795E2,\n\t\t\t\t\t 4.59432382970980127987E3,\n\t\t\t\t\t 2.26290000613890934246E4,\n\t\t\t\t\t 4.92673942608635921086E4\n\t\t\t\t\t};\n\n\tif( Math.abs(x) > 1.0 ) return( 1.0 - errorFunctionComplemented(x) );\n\tz = x * x;\n\ty = x * Polynomial.polevl( z, T, 4 ) \/ Polynomial.p1evl( z, U, 5 );\n\treturn y;\n}\n","comment-text":"Returns the error function of the normal distribution; formerly named <tt>erf<\/tt>.\n The integral is\n <pre>\n                           x \n                            -\n                 2         | |          2\n   erf(x)  =  --------     |    exp( - t  ) dt.\n              sqrt(pi)   | |\n                          -\n                           0\n <\/pre>\n <b>Implementation:<\/b>\n For <tt>0 <= |x| < 1, erf(x) = x * P4(x**2)\/Q5(x**2)<\/tt>; otherwise\n <tt>erf(x) = 1 - erfc(x)<\/tt>.\n <p>\n Code adapted from the <A HREF=\"http:\/\/www.sci.usq.edu.au\/staff\/leighb\/graph\/Top.html\">Java 2D Graph Package 2.4<\/A>,\n which in turn is a port from the <A HREF=\"http:\/\/people.ne.mediaone.net\/moshier\/index.html#Cephes\">Cephes 2.2<\/A> Math Library (C).","line-end":299,"lines":{"279":"\t\t\t\t\t 9.60497373987051638749E0,","278":"\tfinal double T[] = {","277":"\tdouble y, z;","276":"static public double errorFunction(double x) throws ArithmeticException { ","283":"\t\t\t\t\t 5.55923013010394962768E4","282":"\t\t\t\t\t 7.00332514112805075473E3,","281":"\t\t\t\t\t 2.23200534594684319226E3,","280":"\t\t\t\t\t 9.00260197203842689217E1,","287":"\t\t\t\t\t 3.35617141647503099647E1,","286":"\t\t\t\t   \/\/1.00000000000000000000E0,","285":"\tfinal double U[] = {","284":"\t\t\t\t\t};","288":"\t\t\t\t\t 5.21357949780152679795E2,","289":"\t\t\t\t\t 4.59432382970980127987E3,","290":"\t\t\t\t\t 2.26290000613890934246E4,","291":"\t\t\t\t\t 4.92673942608635921086E4","292":"\t\t\t\t\t};","293":"","294":"\tif( Math.abs(x) > 1.0 ) return( 1.0 - errorFunctionComplemented(x) );","295":"\tz = x * x;","296":"\ty = x * Polynomial.polevl( z, T, 4 ) \/ Polynomial.p1evl( z, U, 5 );","297":"\treturn y;","298":"}"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.errorFunction","modifiers":"public static","flat-signature":"(double)","line-start":276,"signature":"(double)","raw-comment-text":" Returns the error function of the normal distribution; formerly named <tt>erf<\/tt>.\n The integral is\n <pre>\n                           x \n                            -\n                 2         | |          2\n   erf(x)  =  --------     |    exp( - t  ) dt.\n              sqrt(pi)   | |\n                          -\n                           0\n <\/pre>\n <b>Implementation:<\/b>\n For <tt>0 <= |x| < 1, erf(x) = x * P4(x**2)\/Q5(x**2)<\/tt>; otherwise\n <tt>erf(x) = 1 - erfc(x)<\/tt>.\n <p>\n Code adapted from the <A HREF=\"http:\/\/www.sci.usq.edu.au\/staff\/leighb\/graph\/Top.html\">Java 2D Graph Package 2.4<\/A>,\n which in turn is a port from the <A HREF=\"http:\/\/people.ne.mediaone.net\/moshier\/index.html#Cephes\">Cephes 2.2<\/A> Math Library (C).\n\n @param a the argument to the function.\n"},"normalInverse":{"tags":{},"source":"static public double normalInverse( double y0) throws ArithmeticException { \n\tdouble x, y, z, y2, x0, x1;\n\tint code;\n\n\tfinal double s2pi = Math.sqrt(2.0*Math.PI);\n\n\tif( y0 <= 0.0 ) throw new IllegalArgumentException();\n\tif( y0 >= 1.0 ) throw new IllegalArgumentException();\n\tcode = 1;\n\ty = y0;\n\tif( y > (1.0 - 0.13533528323661269189) ) { \/* 0.135... = exp(-2) *\/\n\t\ty = 1.0 - y;\n\t\tcode = 0;\n\t}\n\n\tif( y > 0.13533528323661269189 ) {\n\t\ty = y - 0.5;\n\t\ty2 = y * y;\n\t\tx = y + y * (y2 * Polynomial.polevl( y2, P0, 4)\/Polynomial.p1evl( y2, Q0, 8 ));\n\t\tx = x * s2pi; \n\t\treturn(x);\n\t}\n\n\tx = Math.sqrt( -2.0 * Math.log(y) );\n\tx0 = x - Math.log(x)\/x;\n\n\tz = 1.0\/x;\n\tif( x < 8.0 ) \/* y > exp(-32) = 1.2664165549e-14 *\/\n\t\tx1 = z * Polynomial.polevl( z, P1, 8 )\/Polynomial.p1evl( z, Q1, 8 );\n\telse\n\t\tx1 = z * Polynomial.polevl( z, P2, 8 )\/Polynomial.p1evl( z, Q2, 8 );\n\tx = x0 - x1;\n\tif( code != 0 )\n\t\tx = -x;\n\treturn( x );\n}\n","comment-text":"Returns the value, <tt>x<\/tt>, for which the area under the\n Normal (Gaussian) probability density function (integrated from\n minus infinity to <tt>x<\/tt>) is equal to the argument <tt>y<\/tt> (assumes mean is zero, variance is one); formerly named <tt>ndtri<\/tt>.\n <p>\n For small arguments <tt>0 < y < exp(-2)<\/tt>, the program computes\n <tt>z = sqrt( -2.0 * log(y) )<\/tt>;  then the approximation is\n <tt>x = z - log(z)\/z  - (1\/z) P(1\/z) \/ Q(1\/z)<\/tt>.\n There are two rational functions P\/Q, one for <tt>0 < y < exp(-32)<\/tt>\n and the other for <tt>y<\/tt> up to <tt>exp(-2)<\/tt>. \n For larger arguments,\n <tt>w = y - 0.5<\/tt>, and  <tt>x\/sqrt(2pi) = w + w**3 R(w**2)\/S(w**2))<\/tt>.","line-end":610,"lines":{"608":"\treturn( x );","609":"}","575":"\tdouble x, y, z, y2, x0, x1;","574":"static public double normalInverse( double y0) throws ArithmeticException { ","576":"\tint code;","577":"","578":"\tfinal double s2pi = Math.sqrt(2.0*Math.PI);","579":"","580":"\tif( y0 <= 0.0 ) throw new IllegalArgumentException();","581":"\tif( y0 >= 1.0 ) throw new IllegalArgumentException();","582":"\tcode = 1;","583":"\ty = y0;","584":"\tif( y > (1.0 - 0.13533528323661269189) ) { \/* 0.135... = exp(-2) *\/","585":"\t\ty = 1.0 - y;","586":"\t\tcode = 0;","587":"\t}","588":"","589":"\tif( y > 0.13533528323661269189 ) {","590":"\t\ty = y - 0.5;","591":"\t\ty2 = y * y;","593":"\t\tx = x * s2pi; ","592":"\t\tx = y + y * (y2 * Polynomial.polevl( y2, P0, 4)\/Polynomial.p1evl( y2, Q0, 8 ));","595":"\t}","594":"\t\treturn(x);","597":"\tx = Math.sqrt( -2.0 * Math.log(y) );","596":"","599":"","598":"\tx0 = x - Math.log(x)\/x;","601":"\tif( x < 8.0 ) \/* y > exp(-32) = 1.2664165549e-14 *\/","600":"\tz = 1.0\/x;","603":"\telse","602":"\t\tx1 = z * Polynomial.polevl( z, P1, 8 )\/Polynomial.p1evl( z, Q1, 8 );","605":"\tx = x0 - x1;","604":"\t\tx1 = z * Polynomial.polevl( z, P2, 8 )\/Polynomial.p1evl( z, Q2, 8 );","607":"\t\tx = -x;","606":"\tif( code != 0 )"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.normalInverse","modifiers":"public static","flat-signature":"(double)","line-start":574,"signature":"(double)","raw-comment-text":" Returns the value, <tt>x<\/tt>, for which the area under the\n Normal (Gaussian) probability density function (integrated from\n minus infinity to <tt>x<\/tt>) is equal to the argument <tt>y<\/tt> (assumes mean is zero, variance is one); formerly named <tt>ndtri<\/tt>.\n <p>\n For small arguments <tt>0 < y < exp(-2)<\/tt>, the program computes\n <tt>z = sqrt( -2.0 * log(y) )<\/tt>;  then the approximation is\n <tt>x = z - log(z)\/z  - (1\/z) P(1\/z) \/ Q(1\/z)<\/tt>.\n There are two rational functions P\/Q, one for <tt>0 < y < exp(-32)<\/tt>\n and the other for <tt>y<\/tt> up to <tt>exp(-2)<\/tt>. \n For larger arguments,\n <tt>w = y - 0.5<\/tt>, and  <tt>x\/sqrt(2pi) = w + w**3 R(w**2)\/S(w**2))<\/tt>.\n\n"},"chiSquareComplemented":{"tags":{"@param":{"text":"v degrees of freedom.","kind":"@param"}},"source":"static public double chiSquareComplemented(double v, double x) throws ArithmeticException { \n\tif( x < 0.0 || v < 1.0 ) return 0.0;\n\treturn Gamma.incompleteGammaComplement( v\/2.0, x\/2.0 );\n}\n","comment-text":"Returns the area under the right hand tail (from <tt>x<\/tt> to\n infinity) of the Chi square probability density function\n with <tt>v<\/tt> degrees of freedom.\n <pre>\n                                  inf.\n                                    -\n                        1          | |  v\/2-1  -t\/2\n  P( x | v )   =   -----------     |   t      e     dt\n                    v\/2  -       | |\n                   2    | (v\/2)   -\n                                   x\n <\/pre>\n where <tt>x<\/tt> is the Chi-square variable.\n\n The incomplete gamma integral is used, according to the\n formula\n\n <tt>y = chiSquareComplemented( v, x ) = incompleteGammaComplement( v\/2.0, x\/2.0 )<\/tt>.\n\n\n The arguments must both be positive.","line-end":255,"lines":{"254":"}","252":"\tif( x < 0.0 || v < 1.0 ) return 0.0;","253":"\treturn Gamma.incompleteGammaComplement( v\/2.0, x\/2.0 );","251":"static public double chiSquareComplemented(double v, double x) throws ArithmeticException { "},"return-type":"double","qualified-name":"cern.jet.stat.Probability.chiSquareComplemented","modifiers":"public static","flat-signature":"(double, double)","line-start":251,"signature":"(double, double)","raw-comment-text":" Returns the area under the right hand tail (from <tt>x<\/tt> to\n infinity) of the Chi square probability density function\n with <tt>v<\/tt> degrees of freedom.\n <pre>\n                                  inf.\n                                    -\n                        1          | |  v\/2-1  -t\/2\n  P( x | v )   =   -----------     |   t      e     dt\n                    v\/2  -       | |\n                   2    | (v\/2)   -\n                                   x\n <\/pre>\n where <tt>x<\/tt> is the Chi-square variable.\n\n The incomplete gamma integral is used, according to the\n formula\n\n <tt>y = chiSquareComplemented( v, x ) = incompleteGammaComplement( v\/2.0, x\/2.0 )<\/tt>.\n\n\n The arguments must both be positive.\n\n @param v degrees of freedom.\n"},"gamma":{"tags":{"@param":{"text":"x integration end point.","kind":"@param"}},"source":"static public double gamma(double a, double b, double x ) {\n\tif( x < 0.0 ) return 0.0;\n\treturn Gamma.incompleteGamma(b, a*x);\n}\n","comment-text":"Returns the integral from zero to <tt>x<\/tt> of the gamma probability\n density function.\n <pre>\n                x\n        b       -\n       a       | |   b-1  -at\n y =  -----    |    t    e    dt\n       -     | |\n      | (b)   -\n               0\n <\/pre>\n The incomplete gamma integral is used, according to the\n relation\n\n <tt>y = Gamma.incompleteGamma( b, a*x )<\/tt>.","line-end":423,"lines":{"419":"static public double gamma(double a, double b, double x ) {","421":"\treturn Gamma.incompleteGamma(b, a*x);","420":"\tif( x < 0.0 ) return 0.0;","422":"}"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.gamma","modifiers":"public static","flat-signature":"(double, double, double)","line-start":419,"signature":"(double, double, double)","raw-comment-text":" Returns the integral from zero to <tt>x<\/tt> of the gamma probability\n density function.\n <pre>\n                x\n        b       -\n       a       | |   b-1  -at\n y =  -----    |    t    e    dt\n       -     | |\n      | (b)   -\n               0\n <\/pre>\n The incomplete gamma integral is used, according to the\n relation\n\n <tt>y = Gamma.incompleteGamma( b, a*x )<\/tt>.\n\n @param a the paramater a (alpha) of the gamma distribution.\n @param b the paramater b (beta, lambda) of the gamma distribution.\n @param x integration end point.\n"},"poissonComplemented":{"tags":{"@param":{"text":"mean the mean of the poisson distribution.","kind":"@param"}},"source":"static public double poissonComplemented(int k, double mean) throws ArithmeticException { \n\tif( mean < 0 ) throw new IllegalArgumentException();\n\tif( k < -1 ) return 0.0;\n\treturn Gamma.incompleteGamma((double)(k+1),mean);\n}\n","comment-text":"Returns the sum of the terms <tt>k+1<\/tt> to <tt>Infinity<\/tt> of the Poisson distribution.\n <pre>\n  inf.       j\n   --   -m  m\n   >   e    --\n   --       j!\n  j=k+1\n <\/pre>\n The terms are not summed directly; instead the incomplete\n gamma integral is employed, according to the formula\n <p>\n <tt>y = poissonComplemented( k, m ) = Gamma.incompleteGamma( k+1, m )<\/tt>.\n\n The arguments must both be positive.","line-end":658,"lines":{"653":"static public double poissonComplemented(int k, double mean) throws ArithmeticException { ","655":"\tif( k < -1 ) return 0.0;","654":"\tif( mean < 0 ) throw new IllegalArgumentException();","656":"\treturn Gamma.incompleteGamma((double)(k+1),mean);","657":"}"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.poissonComplemented","modifiers":"public static","flat-signature":"(int, double)","line-start":653,"signature":"(int, double)","raw-comment-text":" Returns the sum of the terms <tt>k+1<\/tt> to <tt>Infinity<\/tt> of the Poisson distribution.\n <pre>\n  inf.       j\n   --   -m  m\n   >   e    --\n   --       j!\n  j=k+1\n <\/pre>\n The terms are not summed directly; instead the incomplete\n gamma integral is employed, according to the formula\n <p>\n <tt>y = poissonComplemented( k, m ) = Gamma.incompleteGamma( k+1, m )<\/tt>.\n\n The arguments must both be positive.\n\n @param k start term.\n @param mean the mean of the poisson distribution.\n"},"poisson":{"tags":{"@param":{"text":"mean the mean of the poisson distribution.","kind":"@param"}},"source":"static public double poisson(int k, double mean) throws ArithmeticException { \n\tif( mean < 0 ) throw new IllegalArgumentException();\n\tif( k < 0 ) return 0.0;\n\treturn Gamma.incompleteGammaComplement((double)(k+1) ,mean);\n}\n","comment-text":"Returns the sum of the first <tt>k<\/tt> terms of the Poisson distribution.\n <pre>\n   k         j\n   --   -m  m\n   >   e    --\n   --       j!\n  j=0\n <\/pre>\n The terms are not summed directly; instead the incomplete\n gamma integral is employed, according to the relation\n <p>\n <tt>y = poisson( k, m ) = Gamma.incompleteGammaComplement( k+1, m )<\/tt>.\n\n The arguments must both be positive.","line-end":634,"lines":{"631":"\tif( k < 0 ) return 0.0;","630":"\tif( mean < 0 ) throw new IllegalArgumentException();","629":"static public double poisson(int k, double mean) throws ArithmeticException { ","633":"}","632":"\treturn Gamma.incompleteGammaComplement((double)(k+1) ,mean);"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.poisson","modifiers":"public static","flat-signature":"(int, double)","line-start":629,"signature":"(int, double)","raw-comment-text":" Returns the sum of the first <tt>k<\/tt> terms of the Poisson distribution.\n <pre>\n   k         j\n   --   -m  m\n   >   e    --\n   --       j!\n  j=0\n <\/pre>\n The terms are not summed directly; instead the incomplete\n gamma integral is employed, according to the relation\n <p>\n <tt>y = poisson( k, m ) = Gamma.incompleteGammaComplement( k+1, m )<\/tt>.\n\n The arguments must both be positive.\n\n @param k number of terms.\n @param mean the mean of the poisson distribution.\n"},"negativeBinomialComplemented":{"tags":{"@param":{"text":"p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).","kind":"@param"}},"source":"static public double negativeBinomialComplemented(int k, int n, double p) {\n\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();\n\tif(k < 0) return 0.0;\n\n\treturn Gamma.incompleteBeta( k+1, n, 1.0-p );\n}\n","comment-text":"Returns the sum of the terms <tt>k+1<\/tt> to infinity of the Negative\n Binomial distribution.\n <pre>\n   inf\n   --  ( n+j-1 )   n      j\n   >   (       )  p  (1-p)\n   --  (   j   )\n  j=k+1\n <\/pre>\n The terms are not computed individually; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n y = negativeBinomialComplemented( k, n, p ) = Gamma.incompleteBeta( k+1, n, 1-p ).\n\n All arguments must be positive,","line-end":502,"lines":{"500":"\treturn Gamma.incompleteBeta( k+1, n, 1.0-p );","501":"}","496":"static public double negativeBinomialComplemented(int k, int n, double p) {","497":"\tif( (p < 0.0) || (p > 1.0) ) throw new IllegalArgumentException();","498":"\tif(k < 0) return 0.0;","499":""},"return-type":"double","qualified-name":"cern.jet.stat.Probability.negativeBinomialComplemented","modifiers":"public static","flat-signature":"(int, int, double)","line-start":496,"signature":"(int, int, double)","raw-comment-text":" Returns the sum of the terms <tt>k+1<\/tt> to infinity of the Negative\n Binomial distribution.\n <pre>\n   inf\n   --  ( n+j-1 )   n      j\n   >   (       )  p  (1-p)\n   --  (   j   )\n  j=k+1\n <\/pre>\n The terms are not computed individually; instead the incomplete\n beta integral is employed, according to the formula\n <p>\n y = negativeBinomialComplemented( k, n, p ) = Gamma.incompleteBeta( k+1, n, 1-p ).\n\n All arguments must be positive, \n @param k end term.\n @param n the number of trials.\n @param p the probability of success (must be in <tt>(0.0,1.0)<\/tt>).\n"},"errorFunctionComplemented":{"tags":{"@param":{"text":"a the argument to the function.","kind":"@param"}},"source":"static public double errorFunctionComplemented(double a) throws ArithmeticException { \n\tdouble x,y,z,p,q;\n\n\tdouble P[] = {\n\t\t\t\t\t 2.46196981473530512524E-10,\n\t\t\t\t\t 5.64189564831068821977E-1,\n\t\t\t\t\t 7.46321056442269912687E0,\n\t\t\t\t\t 4.86371970985681366614E1,\n\t\t\t\t\t 1.96520832956077098242E2,\n\t\t\t\t\t 5.26445194995477358631E2,\n\t\t\t\t\t 9.34528527171957607540E2,\n\t\t\t\t\t 1.02755188689515710272E3,\n\t\t\t\t\t 5.57535335369399327526E2\n\t\t\t\t\t};\n\tdouble Q[] = {\n\t\t\t\t\t\/\/1.0\n\t\t\t\t\t  1.32281951154744992508E1,\n\t\t\t\t\t  8.67072140885989742329E1,\n\t\t\t\t\t  3.54937778887819891062E2,\n\t\t\t\t\t  9.75708501743205489753E2,\n\t\t\t\t\t  1.82390916687909736289E3,\n\t\t\t\t\t  2.24633760818710981792E3,\n\t\t\t\t\t  1.65666309194161350182E3,\n\t\t\t\t\t  5.57535340817727675546E2\n\t\t\t\t\t };\n\n\tdouble R[] = {\n\t\t\t\t\t  5.64189583547755073984E-1,\n\t\t\t\t\t  1.27536670759978104416E0,\n\t\t\t\t\t  5.01905042251180477414E0,\n\t\t\t\t\t  6.16021097993053585195E0,\n\t\t\t\t\t  7.40974269950448939160E0,\n\t\t\t\t\t  2.97886665372100240670E0\n\t\t\t\t\t };\n\tdouble S[] = {\n\t\t\t\t\t\/\/1.00000000000000000000E0, \n\t\t\t\t\t  2.26052863220117276590E0,\n\t\t\t\t\t  9.39603524938001434673E0,\n\t\t\t\t\t  1.20489539808096656605E1,\n\t\t\t\t\t  1.70814450747565897222E1,\n\t\t\t\t\t  9.60896809063285878198E0,\n\t\t\t\t\t  3.36907645100081516050E0\n\t\t\t\t\t };\n\n\tif( a < 0.0 )   x = -a;\n\telse            x = a;\n\n\tif( x < 1.0 )   return 1.0 - errorFunction(a);\n\n\tz = -a * a;\n\n\tif( z < -MAXLOG ) {\n\t\t if( a < 0 )  return( 2.0 );\n\t\t else         return( 0.0 );\n\t}\n\n\tz = Math.exp(z);\n\n\tif( x < 8.0 ) {\n\t  p = Polynomial.polevl( x, P, 8 );\n\t  q = Polynomial.p1evl( x, Q, 8 );\n\t} else {\n\t  p = Polynomial.polevl( x, R, 5 );\n\t  q = Polynomial.p1evl( x, S, 6 );\n\t}\n\n\ty = (z * p)\/q;\n\n\tif( a < 0 ) y = 2.0 - y;\n\n\tif( y == 0.0 ) {\n\t\t\tif( a < 0 ) return 2.0;\n\t\t\telse        return( 0.0 );\n\t }\n\n\treturn y;\n}\n","comment-text":"Returns the complementary Error function of the normal distribution; formerly named <tt>erfc<\/tt>.\n <pre>\n  1 - erf(x) =\n\n                           inf. \n                             -\n                  2         | |          2\n   erfc(x)  =  --------     |    exp( - t  ) dt\n               sqrt(pi)   | |\n                           -\n                            x\n <\/pre>\n <b>Implementation:<\/b>\n For small x, <tt>erfc(x) = 1 - erf(x)<\/tt>; otherwise rational\n approximations are computed.\n <p>\n Code adapted from the <A HREF=\"http:\/\/www.sci.usq.edu.au\/staff\/leighb\/graph\/Top.html\">Java 2D Graph Package 2.4<\/A>,\n which in turn is a port from the <A HREF=\"http:\/\/people.ne.mediaone.net\/moshier\/index.html#Cephes\">Cephes 2.2<\/A> Math Library (C).","line-end":398,"lines":{"395":"","394":"\t }","393":"\t\t\telse        return( 0.0 );","392":"\t\t\tif( a < 0 ) return 2.0;","397":"}","396":"\treturn y;","387":"\ty = (z * p)\/q;","386":"","385":"\t}","384":"\t  q = Polynomial.p1evl( x, S, 6 );","391":"\tif( y == 0.0 ) {","390":"","389":"\tif( a < 0 ) y = 2.0 - y;","388":"","343":"\t\t\t\t\t  1.65666309194161350182E3,","342":"\t\t\t\t\t  2.24633760818710981792E3,","341":"\t\t\t\t\t  1.82390916687909736289E3,","340":"\t\t\t\t\t  9.75708501743205489753E2,","339":"\t\t\t\t\t  3.54937778887819891062E2,","338":"\t\t\t\t\t  8.67072140885989742329E1,","337":"\t\t\t\t\t  1.32281951154744992508E1,","336":"\t\t\t\t\t\/\/1.0","351":"\t\t\t\t\t  6.16021097993053585195E0,","350":"\t\t\t\t\t  5.01905042251180477414E0,","349":"\t\t\t\t\t  1.27536670759978104416E0,","348":"\t\t\t\t\t  5.64189583547755073984E-1,","347":"\tdouble R[] = {","346":"","345":"\t\t\t\t\t };","344":"\t\t\t\t\t  5.57535340817727675546E2","326":"\t\t\t\t\t 5.64189564831068821977E-1,","327":"\t\t\t\t\t 7.46321056442269912687E0,","324":"\tdouble P[] = {","325":"\t\t\t\t\t 2.46196981473530512524E-10,","322":"\tdouble x,y,z,p,q;","323":"","321":"static public double errorFunctionComplemented(double a) throws ArithmeticException { ","334":"\t\t\t\t\t};","335":"\tdouble Q[] = {","332":"\t\t\t\t\t 1.02755188689515710272E3,","333":"\t\t\t\t\t 5.57535335369399327526E2","330":"\t\t\t\t\t 5.26445194995477358631E2,","331":"\t\t\t\t\t 9.34528527171957607540E2,","328":"\t\t\t\t\t 4.86371970985681366614E1,","329":"\t\t\t\t\t 1.96520832956077098242E2,","373":"\t\t if( a < 0 )  return( 2.0 );","372":"\tif( z < -MAXLOG ) {","375":"\t}","374":"\t\t else         return( 0.0 );","369":"","368":"\tif( x < 1.0 )   return 1.0 - errorFunction(a);","371":"","370":"\tz = -a * a;","381":"\t  q = Polynomial.p1evl( x, Q, 8 );","380":"\t  p = Polynomial.polevl( x, P, 8 );","383":"\t  p = Polynomial.polevl( x, R, 5 );","382":"\t} else {","377":"\tz = Math.exp(z);","376":"","379":"\tif( x < 8.0 ) {","378":"","356":"\t\t\t\t\t\/\/1.00000000000000000000E0, ","357":"\t\t\t\t\t  2.26052863220117276590E0,","358":"\t\t\t\t\t  9.39603524938001434673E0,","359":"\t\t\t\t\t  1.20489539808096656605E1,","352":"\t\t\t\t\t  7.40974269950448939160E0,","353":"\t\t\t\t\t  2.97886665372100240670E0","354":"\t\t\t\t\t };","355":"\tdouble S[] = {","364":"","365":"\tif( a < 0.0 )   x = -a;","366":"\telse            x = a;","367":"","360":"\t\t\t\t\t  1.70814450747565897222E1,","361":"\t\t\t\t\t  9.60896809063285878198E0,","362":"\t\t\t\t\t  3.36907645100081516050E0","363":"\t\t\t\t\t };"},"return-type":"double","qualified-name":"cern.jet.stat.Probability.errorFunctionComplemented","modifiers":"public static","flat-signature":"(double)","line-start":321,"signature":"(double)","raw-comment-text":" Returns the complementary Error function of the normal distribution; formerly named <tt>erfc<\/tt>.\n <pre>\n  1 - erf(x) =\n\n                           inf. \n                             -\n                  2         | |          2\n   erfc(x)  =  --------     |    exp( - t  ) dt\n               sqrt(pi)   | |\n                           -\n                            x\n <\/pre>\n <b>Implementation:<\/b>\n For small x, <tt>erfc(x) = 1 - erf(x)<\/tt>; otherwise rational\n approximations are computed.\n <p>\n Code adapted from the <A HREF=\"http:\/\/www.sci.usq.edu.au\/staff\/leighb\/graph\/Top.html\">Java 2D Graph Package 2.4<\/A>,\n which in turn is a port from the <A HREF=\"http:\/\/people.ne.mediaone.net\/moshier\/index.html#Cephes\">Cephes 2.2<\/A> Math Library (C).\n\n @param a the argument to the function.\n"}},"tags":{"@author":{"text":"wolfgang.hoschek@cern.ch","kind":"@author"},"@version":{"text":"0.91, 08-Dec-99","kind":"@version"}},"superclass":"cern.jet.math.Constants","comment-text":"Custom tailored numerical integration of certain probability distributions.\n <p>\n <b>Implementation:<\/b>\n <dt>\n Some code taken and adapted from the <A HREF=\"http:\/\/www.sci.usq.edu.au\/staff\/leighb\/graph\/Top.html\">Java 2D Graph Package 2.4<\/A>,\n which in turn is a port from the <A HREF=\"http:\/\/people.ne.mediaone.net\/moshier\/index.html#Cephes\">Cephes 2.2<\/A> Math Library (C).\n Most Cephes code (missing from the 2D Graph Package) directly ported.","package":"cern.jet.stat","source-file":"stat\/Probability.java","qualified-name":"cern.jet.stat.Probability","line-start":25,"fields":{"Q0":{"comment-text":"","qualified-name":"cern.jet.stat.Probability.Q0","type":"double[]"},"Q1":{"comment-text":"","qualified-name":"cern.jet.stat.Probability.Q1","type":"double[]"},"Q2":{"comment-text":"","qualified-name":"cern.jet.stat.Probability.Q2","type":"double[]"},"P1":{"comment-text":"","qualified-name":"cern.jet.stat.Probability.P1","type":"double[]"},"P0":{"comment-text":"COEFFICIENTS FOR METHOD  normalInverse()   *","qualified-name":"cern.jet.stat.Probability.P0","type":"double[]"},"P2":{"comment-text":"","qualified-name":"cern.jet.stat.Probability.P2","type":"double[]"}}},"Gamma":{"methods":{"logGamma":{"550":"","551":"\t\t q = ( x - 0.5 ) * Math.log(x) - x + 0.91893853320467274178;","548":"\t\t if( x > 2.556348e305 ) throw new ","549":"\t\t\t\t\t\t  ArithmeticException(\"lgamma: Overflow\");","546":"\t }","547":"","544":"\t   p = x * Polynomial.polevl( x, B, 5 ) \/ Polynomial.p1evl( x, C, 6);","545":" \t   return( Math.log(z) + p );","558":"\t\t      - 2.7777777777777777777778e-3) *p","559":"\t\t     + 0.0833333333333333333333) \/ x;","556":"\t\t if( x >= 1000.0 )","557":"\t     q += ((   7.9365079365079365079365e-4 * p","554":"","555":"\t\t p = 1.0\/(x*x);","552":"\t\t \/\/if( x > 1.0e8 ) return( q );","553":"\t\t if( x > 1.0e8 ) return( q );","567":" *\/","566":" * Use when b*x is small and x not too close to 1.  ","565":" * Power series for incomplete beta integral; formerly named <tt>pseries<\/tt>.","564":"\/**","563":"\t }","562":"\t\t return q;","561":"\t     q += Polynomial.polevl( p, A, 4 ) \/ x;","560":"\t\t else","575":"\tt = u;","574":"\tt1 = v;","573":"\tv = u \/ (a + 1.0);","572":"\tu = (1.0 - b) * x;","571":"\tai = 1.0 \/ a;","570":"","signature":"(double)","569":"\tdouble s, t, u, v, n, t1, z, ai;","568":"static double powerSeries( double a, double b, double x ) throws ArithmeticException {","516":"\t   if( p == q ) throw new ArithmeticException(\"lgam: Overflow\");","517":"\t   z = q - p;","518":"\t   if( z > 0.5 ) {","519":"\t\tp += 1.0;","512":"\t\t if( x < -34.0 ) {","513":"  \t   q = -x;","514":"\t   w = logGamma(q);","515":"\t   p = Math.floor(q);","524":"\t\t\t\t\t\t\t   ArithmeticException(\"lgamma: Overflow\");","525":"\t   z = LOGPI - Math.log( z ) - w;","526":"\t   return z;","527":"\t }","520":"\t\tz = p - q;","521":" \t   }","522":"\t   z = q * Math.sin( Math.PI * z );","523":"\t   if( z == 0.0 ) throw new ","533":"\t\tz *= x;","532":"\t\tx -= 1.0;","535":"\t   while( x < 2.0 ) {","534":"\t   }","529":"\t\t if( x < 13.0 ) {","comment-text":"Returns the natural logarithm of the gamma function; formerly named <tt>lgamma<\/tt>.","528":"","531":"\t   while( x >= 3.0 ) {","530":"  \t   z = 1.0;","541":"\t   if( z < 0.0 ) z = -z;","540":"\t   }","lines":{},"543":"\t   x -= 2.0;","542":"\t   if( x == 2.0 ) return Math.log(z);","537":"\t\t\t\t\t\t\t\tArithmeticException(\"lgamma: Overflow\");","536":"\t\tif( x == 0.0 ) throw new ","539":"\t\tx += 1.0;","538":"\t\tz \/= x;","610":"\t\t\t\t\t 8.33333333333482257126E-2,","611":"\t\t\t\t\t};","608":"\t\t\t\t\t-2.68132617805781232825E-3,","609":"\t\t\t\t\t 3.47222221605458667310E-3,","614":"\t\tdouble w = 1.0\/x;","615":"\t\tdouble  y = Math.exp(x);","612":"\t\tdouble MAXSTIR = 143.01608;","613":"","618":"","619":"\t\tif( x > MAXSTIR ) {","616":"","617":"\t\tw = 1.0 + w * Polynomial.polevl( w, STIR, 4 );","622":"\t       y = v * (v \/ y);","623":"\t} else {","620":"\t       \/* Avoid overflow in Math.pow() *\/","line-start":484,"621":"\t       double v = Math.pow( x, 0.5 * x - 0.25 );","627":"\t\treturn y;","626":"\t\ty = SQTPI * y * w;","625":"\t}","624":"\t\t\t   y = Math.pow( x, x - 0.5 ) \/ y;","629":"}","628":"\t }","modifiers":"public static","tags":{},"576":"\tn = 2.0;","577":"\ts = 0.0;","578":"\tz = MACHEP * ai;","579":"\twhile( Math.abs(v) > z ) {","580":"\t       u = (n - b) * x \/ n;","581":"\t       t *= u;","582":"\t       v = t \/ (a + n);","583":"\t       s += v; ","584":"\t       n += 1.0;","585":"\t    }","586":"\ts += t1;","587":"\ts += ai;","588":"","589":"\tu = a * Math.log(x);","590":"\tif( (a+b) < MAXGAM && Math.abs(u) < MAXLOG ) {","591":"\t        t = Gamma.gamma(a+b)\/(Gamma.gamma(a)*Gamma.gamma(b));","593":"\t    } else {","592":"\t        s = s * t * Math.pow(x,a);","595":"\t       if( t < MINLOG ) \ts = 0.0;","594":"\t       t = Gamma.logGamma(a+b) - Gamma.logGamma(a) - Gamma.logGamma(b) + u + Math.log(s);","597":"\t    }","596":"\t       else  \t            s = Math.exp(t);","599":"}","598":"\treturn s;","601":" * Returns the Gamma function computed by Stirling's formula; formerly named <tt>stirf<\/tt>.","600":"\/**","603":" *\/","602":" * The polynomial STIR is valid for 33 <= x <= 172.","605":"\t\tdouble STIR[] = {","604":"static double stirlingFormula(double x) throws ArithmeticException {","607":"\t\t\t\t\t-2.29549961613378126380E-4,","raw-comment-text":" Returns the natural logarithm of the gamma function; formerly named <tt>lgamma<\/tt>.\n","606":"\t\t\t\t\t 7.87311395793093628397E-4,","return-type":"double","508":"\t\t\t\t\t   -2.53252307177582951285E6,","509":"\t\t\t\t\t   -2.01889141433532773231E6","510":"\t\t\t\t\t  };","511":"","504":"\t\t\t\t\t   -3.51815701436523470549E2,","505":"\t\t\t\t\t   -1.70642106651881159223E4,","506":"\t\t\t\t\t   -2.20528590553854454839E5,","507":"\t\t\t\t\t   -1.13933444367982507207E6,","500":"\t\t\t\t\t   -8.53555664245765465627E5","501":"\t\t\t\t\t   };","502":"\t\t double C[] = {","503":"\t\t\t\t\t   \/* 1.00000000000000000000E0, *\/","496":"\t\t\t\t\t   -3.88016315134637840924E4,","497":"\t\t\t\t\t   -3.31612992738871184744E5,","498":"\t\t\t\t\t   -1.16237097492762307383E6,","499":"\t\t\t\t\t   -1.72173700820839662146E6,","493":"\t\t\t\t\t   };","492":"\t\t\t\t\t\t8.33333333333331927722E-2","495":"\t\t\t\t\t   -1.37825152569120859100E3,","494":"\t\t double B[] = {","source":"public static double logGamma(double x) throws ArithmeticException {\n\tdouble p, q, w, z;\n\n\t\t double A[] = {\n\t\t\t\t\t   8.11614167470508450300E-4,\n\t\t\t\t\t   -5.95061904284301438324E-4,\n\t\t\t\t\t\t7.93650340457716943945E-4,\n\t\t\t\t\t   -2.77777777730099687205E-3,\n\t\t\t\t\t\t8.33333333333331927722E-2\n\t\t\t\t\t   };\n\t\t double B[] = {\n\t\t\t\t\t   -1.37825152569120859100E3,\n\t\t\t\t\t   -3.88016315134637840924E4,\n\t\t\t\t\t   -3.31612992738871184744E5,\n\t\t\t\t\t   -1.16237097492762307383E6,\n\t\t\t\t\t   -1.72173700820839662146E6,\n\t\t\t\t\t   -8.53555664245765465627E5\n\t\t\t\t\t   };\n\t\t double C[] = {\n\t\t\t\t\t   \/* 1.00000000000000000000E0, *\/\n\t\t\t\t\t   -3.51815701436523470549E2,\n\t\t\t\t\t   -1.70642106651881159223E4,\n\t\t\t\t\t   -2.20528590553854454839E5,\n\t\t\t\t\t   -1.13933444367982507207E6,\n\t\t\t\t\t   -2.53252307177582951285E6,\n\t\t\t\t\t   -2.01889141433532773231E6\n\t\t\t\t\t  };\n\n\t\t if( x < -34.0 ) {\n  \t   q = -x;\n\t   w = logGamma(q);\n\t   p = Math.floor(q);\n\t   if( p == q ) throw new ArithmeticException(\"lgam: Overflow\");\n\t   z = q - p;\n\t   if( z > 0.5 ) {\n\t\tp += 1.0;\n\t\tz = p - q;\n \t   }\n\t   z = q * Math.sin( Math.PI * z );\n\t   if( z == 0.0 ) throw new \n\t\t\t\t\t\t\t   ArithmeticException(\"lgamma: Overflow\");\n\t   z = LOGPI - Math.log( z ) - w;\n\t   return z;\n\t }\n\n\t\t if( x < 13.0 ) {\n  \t   z = 1.0;\n\t   while( x >= 3.0 ) {\n\t\tx -= 1.0;\n\t\tz *= x;\n\t   }\n\t   while( x < 2.0 ) {\n\t\tif( x == 0.0 ) throw new \n\t\t\t\t\t\t\t\tArithmeticException(\"lgamma: Overflow\");\n\t\tz \/= x;\n\t\tx += 1.0;\n\t   }\n\t   if( z < 0.0 ) z = -z;\n\t   if( x == 2.0 ) return Math.log(z);\n\t   x -= 2.0;\n\t   p = x * Polynomial.polevl( x, B, 5 ) \/ Polynomial.p1evl( x, C, 6);\n \t   return( Math.log(z) + p );\n\t }\n\n\t\t if( x > 2.556348e305 ) throw new \n\t\t\t\t\t\t  ArithmeticException(\"lgamma: Overflow\");\n\n\t\t q = ( x - 0.5 ) * Math.log(x) - x + 0.91893853320467274178;\n\t\t \/\/if( x > 1.0e8 ) return( q );\n\t\t if( x > 1.0e8 ) return( q );\n\n\t\t p = 1.0\/(x*x);\n\t\t if( x >= 1000.0 )\n\t     q += ((   7.9365079365079365079365e-4 * p\n\t\t      - 2.7777777777777777777778e-3) *p\n\t\t     + 0.0833333333333333333333) \/ x;\n\t\t else\n\t     q += Polynomial.polevl( p, A, 4 ) \/ x;\n\t\t return q;\n\t }\n\/**\n * Power series for incomplete beta integral; formerly named <tt>pseries<\/tt>.\n * Use when b*x is small and x not too close to 1.  \n *\/\nstatic double powerSeries( double a, double b, double x ) throws ArithmeticException {\n\tdouble s, t, u, v, n, t1, z, ai;\n\n\tai = 1.0 \/ a;\n\tu = (1.0 - b) * x;\n\tv = u \/ (a + 1.0);\n\tt1 = v;\n\tt = u;\n\tn = 2.0;\n\ts = 0.0;\n\tz = MACHEP * ai;\n\twhile( Math.abs(v) > z ) {\n\t       u = (n - b) * x \/ n;\n\t       t *= u;\n\t       v = t \/ (a + n);\n\t       s += v; \n\t       n += 1.0;\n\t    }\n\ts += t1;\n\ts += ai;\n\n\tu = a * Math.log(x);\n\tif( (a+b) < MAXGAM && Math.abs(u) < MAXLOG ) {\n\t        t = Gamma.gamma(a+b)\/(Gamma.gamma(a)*Gamma.gamma(b));\n\t        s = s * t * Math.pow(x,a);\n\t    } else {\n\t       t = Gamma.logGamma(a+b) - Gamma.logGamma(a) - Gamma.logGamma(b) + u + Math.log(s);\n\t       if( t < MINLOG ) \ts = 0.0;\n\t       else  \t            s = Math.exp(t);\n\t    }\n\treturn s;\n}\n\/**\n * Returns the Gamma function computed by Stirling's formula; formerly named <tt>stirf<\/tt>.\n * The polynomial STIR is valid for 33 <= x <= 172.\n *\/\nstatic double stirlingFormula(double x) throws ArithmeticException {\n\t\tdouble STIR[] = {\n\t\t\t\t\t 7.87311395793093628397E-4,\n\t\t\t\t\t-2.29549961613378126380E-4,\n\t\t\t\t\t-2.68132617805781232825E-3,\n\t\t\t\t\t 3.47222221605458667310E-3,\n\t\t\t\t\t 8.33333333333482257126E-2,\n\t\t\t\t\t};\n\t\tdouble MAXSTIR = 143.01608;\n\n\t\tdouble w = 1.0\/x;\n\t\tdouble  y = Math.exp(x);\n\n\t\tw = 1.0 + w * Polynomial.polevl( w, STIR, 4 );\n\n\t\tif( x > MAXSTIR ) {\n\t       \/* Avoid overflow in Math.pow() *\/\n\t       double v = Math.pow( x, 0.5 * x - 0.25 );\n\t       y = v * (v \/ y);\n\t} else {\n\t\t\t   y = Math.pow( x, x - 0.5 ) \/ y;\n\t}\n\t\ty = SQTPI * y * w;\n\t\treturn y;\n\t }\n}\n","489":"\t\t\t\t\t   -5.95061904284301438324E-4,","488":"\t\t\t\t\t   8.11614167470508450300E-4,","491":"\t\t\t\t\t   -2.77777777730099687205E-3,","490":"\t\t\t\t\t\t7.93650340457716943945E-4,","485":"\tdouble p, q, w, z;","484":"public static double logGamma(double x) throws ArithmeticException {","487":"\t\t double A[] = {","486":"","qualified-name":"cern.jet.stat.Gamma.logGamma","flat-signature":"(double)"},"gamma":{"tags":{},"source":"static public double gamma(double x) throws ArithmeticException {\n\ndouble P[] = {\n\t\t\t   1.60119522476751861407E-4,\n\t\t\t   1.19135147006586384913E-3,\n\t\t\t   1.04213797561761569935E-2,\n\t\t\t   4.76367800457137231464E-2,\n\t\t\t   2.07448227648435975150E-1,\n\t\t\t   4.94214826801497100753E-1,\n\t\t\t   9.99999999999999996796E-1\n\t\t\t  };\ndouble Q[] = {\n\t\t\t   -2.31581873324120129819E-5,\n\t\t\t\t5.39605580493303397842E-4,\n\t\t\t   -4.45641913851797240494E-3,\n\t\t\t\t1.18139785222060435552E-2,\n\t\t\t\t3.58236398605498653373E-2,\n\t\t\t   -2.34591795718243348568E-1,\n\t\t\t\t7.14304917030273074085E-2,\n\t\t\t\t1.00000000000000000320E0\n\t\t\t   };\n\/\/double MAXGAM = 171.624376956302725;\n\/\/double LOGPI  = 1.14472988584940017414;\n\ndouble p, z;\nint i;\n\ndouble q = Math.abs(x);\n\nif( q > 33.0 ) {\n   if( x < 0.0 ) {\n\t\tp = Math.floor(q);\n\tif( p == q ) throw new ArithmeticException(\"gamma: overflow\");\n\ti = (int)p;\n\tz = q - p;\n\tif( z > 0.5 ) {\n\t\tp += 1.0;\n\t\tz = q - p;\n\t}\n\tz = q * Math.sin( Math.PI * z );\n\tif( z == 0.0 ) throw new ArithmeticException(\"gamma: overflow\");\n\tz = Math.abs(z);\n\tz = Math.PI\/(z * stirlingFormula(q) );\n\n\t\treturn -z;\n   } else {\n\treturn stirlingFormula(x);\n   }\n }\n\n z = 1.0;\n   while( x >= 3.0 ) {\n  \t     x -= 1.0;\n\t z *= x;\n   }\n\n   while( x < 0.0 ) {\n\t if( x == 0.0 ) {\n\t\t\tthrow new ArithmeticException(\"gamma: singular\");\n\t\t } else\n\t if( x > -1.E-9 ) {\n\t\t\t return( z\/((1.0 + 0.5772156649015329 * x) * x) );\n\t\t }\n\t z \/= x;\n\t x += 1.0;\n   }\n\n   while( x < 2.0 ) {\n\t if( x == 0.0 ) {\n\t\t\tthrow new ArithmeticException(\"gamma: singular\");\n\t\t } else\n\t if( x < 1.e-9 ) {\n  \t        return( z\/((1.0 + 0.5772156649015329 * x) * x) );\n\t\t }\n\t z \/= x;\n\t x += 1.0;\n}\n\n\tif( (x == 2.0) || (x == 3.0) ) \treturn z;\n\n\tx -= 2.0;\n\tp = Polynomial.polevl( x, P, 6 );\n\tq = Polynomial.polevl( x, Q, 7 );\n\treturn  z * p \/ q;\n\n}\n","comment-text":"Returns the Gamma function of the argument.","line-end":146,"lines":{"137":"","136":"}","139":"","138":"\tif( (x == 2.0) || (x == 3.0) ) \treturn z;","141":"\tp = Polynomial.polevl( x, P, 6 );","140":"\tx -= 2.0;","143":"\treturn  z * p \/ q;","142":"\tq = Polynomial.polevl( x, Q, 7 );","129":"\t\t\tthrow new ArithmeticException(\"gamma: singular\");","128":"\t if( x == 0.0 ) {","131":"\t if( x < 1.e-9 ) {","130":"\t\t } else","133":"\t\t }","132":"  \t        return( z\/((1.0 + 0.5772156649015329 * x) * x) );","135":"\t x += 1.0;","134":"\t z \/= x;","144":"","145":"}","63":"\t\t\t   1.60119522476751861407E-4,","62":"double P[] = {","61":"","60":"static public double gamma(double x) throws ArithmeticException {","68":"\t\t\t   4.94214826801497100753E-1,","69":"\t\t\t   9.99999999999999996796E-1","70":"\t\t\t  };","71":"double Q[] = {","64":"\t\t\t   1.19135147006586384913E-3,","65":"\t\t\t   1.04213797561761569935E-2,","66":"\t\t\t   4.76367800457137231464E-2,","67":"\t\t\t   2.07448227648435975150E-1,","76":"\t\t\t\t3.58236398605498653373E-2,","77":"\t\t\t   -2.34591795718243348568E-1,","78":"\t\t\t\t7.14304917030273074085E-2,","79":"\t\t\t\t1.00000000000000000320E0","72":"\t\t\t   -2.31581873324120129819E-5,","73":"\t\t\t\t5.39605580493303397842E-4,","74":"\t\t\t   -4.45641913851797240494E-3,","75":"\t\t\t\t1.18139785222060435552E-2,","85":"int i;","84":"double p, z;","87":"double q = Math.abs(x);","86":"","81":"\/\/double MAXGAM = 171.624376956302725;","80":"\t\t\t   };","83":"","82":"\/\/double LOGPI  = 1.14472988584940017414;","93":"\ti = (int)p;","92":"\tif( p == q ) throw new ArithmeticException(\"gamma: overflow\");","95":"\tif( z > 0.5 ) {","94":"\tz = q - p;","89":"if( q > 33.0 ) {","88":"","91":"\t\tp = Math.floor(q);","90":"   if( x < 0.0 ) {","102":"\tz = Math.PI\/(z * stirlingFormula(q) );","103":"","100":"\tif( z == 0.0 ) throw new ArithmeticException(\"gamma: overflow\");","101":"\tz = Math.abs(z);","98":"\t}","99":"\tz = q * Math.sin( Math.PI * z );","96":"\t\tp += 1.0;","97":"\t\tz = q - p;","110":" z = 1.0;","111":"   while( x >= 3.0 ) {","108":" }","109":"","106":"\treturn stirlingFormula(x);","107":"   }","104":"\t\treturn -z;","105":"   } else {","119":"\t\t } else","118":"\t\t\tthrow new ArithmeticException(\"gamma: singular\");","117":"\t if( x == 0.0 ) {","116":"   while( x < 0.0 ) {","115":"","114":"   }","113":"\t z *= x;","112":"  \t     x -= 1.0;","127":"   while( x < 2.0 ) {","126":"","125":"   }","124":"\t x += 1.0;","123":"\t z \/= x;","122":"\t\t }","121":"\t\t\t return( z\/((1.0 + 0.5772156649015329 * x) * x) );","120":"\t if( x > -1.E-9 ) {"},"return-type":"double","qualified-name":"cern.jet.stat.Gamma.gamma","modifiers":"public static","flat-signature":"(double)","line-start":60,"signature":"(double)","raw-comment-text":" Returns the Gamma function of the argument.\n"},"incompleteGamma":{"tags":{"@param":{"text":"x the integration end point.","kind":"@param"}},"source":"static public double incompleteGamma(double a, double x) \n\t\t\t\t\t\t throws ArithmeticException {\n\n\n\t\tdouble ans, ax, c, r;\n\n\t\tif( x <= 0 || a <= 0 ) return 0.0;\n\n\t\tif( x > 1.0 && x > a ) return 1.0 - incompleteGammaComplement(a,x);\n\n\t   \/* Compute  x**a * exp(-x) \/ gamma(a)  *\/\n\t\tax = a * Math.log(x) - x - logGamma(a);\n\t\tif( ax < -MAXLOG ) return( 0.0 );\n\n\t\tax = Math.exp(ax);\n\n\t\t\/* power series *\/\n\t\tr = a;\n\t\tc = 1.0;\n\t\tans = 1.0;\n\n\t\tdo {\n  \t    r += 1.0;\n\t    c *= x\/r;\n\t    ans += c;\n\t}\n\t\twhile( c\/ans > MACHEP );\n\n\t\treturn( ans * ax\/a );\n\n\t }\n","comment-text":"Returns the Incomplete Gamma function; formerly named <tt>igamma<\/tt>.","line-end":425,"lines":{"410":"\t\t\/* power series *\/","411":"\t\tr = a;","408":"\t\tax = Math.exp(ax);","409":"","414":"","415":"\t\tdo {","412":"\t\tc = 1.0;","413":"\t\tans = 1.0;","402":"\t\tif( x > 1.0 && x > a ) return 1.0 - incompleteGammaComplement(a,x);","403":"","400":"\t\tif( x <= 0 || a <= 0 ) return 0.0;","401":"","406":"\t\tif( ax < -MAXLOG ) return( 0.0 );","407":"","404":"\t   \/* Compute  x**a * exp(-x) \/ gamma(a)  *\/","405":"\t\tax = a * Math.log(x) - x - logGamma(a);","395":"\t\t\t\t\t\t throws ArithmeticException {","394":"static public double incompleteGamma(double a, double x) ","399":"","398":"\t\tdouble ans, ax, c, r;","397":"","396":"","424":"\t }","417":"\t    c *= x\/r;","416":"  \t    r += 1.0;","419":"\t}","418":"\t    ans += c;","421":"","420":"\t\twhile( c\/ans > MACHEP );","423":"","422":"\t\treturn( ans * ax\/a );"},"return-type":"double","qualified-name":"cern.jet.stat.Gamma.incompleteGamma","modifiers":"public static","flat-signature":"(double, double)","line-start":394,"signature":"(double, double)","raw-comment-text":" Returns the Incomplete Gamma function; formerly named <tt>igamma<\/tt>.\n @param a the parameter of the gamma distribution.\n @param x the integration end point.\n"},"incompleteBeta":{"tags":{"@param":{"text":"xx the integration end point.","kind":"@param"}},"source":"public static double incompleteBeta( double aa, double bb, double xx ) throws ArithmeticException {\n\t\tdouble a, b, t, x, xc, w, y;\n\t\tboolean flag;\n\n\t\tif( aa <= 0.0 || bb <= 0.0 ) throw new \n\t\t\t\t\t\t  ArithmeticException(\"ibeta: Domain error!\");\n\n\t\tif( (xx <= 0.0) || ( xx >= 1.0) ) {\n  \t       if( xx == 0.0 ) return 0.0;\n   \t       if( xx == 1.0 ) return 1.0;\n\t\t   throw new ArithmeticException(\"ibeta: Domain error!\");\n\t    }\n\n\t\tflag = false;\n\t\tif( (bb * xx) <= 1.0 && xx <= 0.95) {\n\t        t = powerSeries(aa, bb, xx);\n\t\t    return t;\n\t    }\n\n\t\tw = 1.0 - xx;\n\n\t\t\/* Reverse a and b if x is greater than the mean. *\/\n\t\tif( xx > (aa\/(aa+bb)) ) {\n\t       flag = true;\n\t       a = bb;\n\t       b = aa;\n\t       xc = xx;\n\t       x = w;\n\t    } else {\n  \t       a = aa;\n\t       b = bb;\n\t       xc = w;\n\t       x = xx;\n\t    }\n\n\t\tif( flag  && (b * x) <= 1.0 && x <= 0.95) {\n \t       t = powerSeries(a, b, x);\n\t       if( t <= MACHEP ) \tt = 1.0 - MACHEP;\n\t       else  \t\t        t = 1.0 - t;\n\t\t   return t;\n\t    }\n\n\t\t\/* Choose expansion for better convergence. *\/\n\t\ty = x * (a+b-2.0) - (a-1.0);\n\t\tif( y < 0.0 )\n\t                  w = incompleteBetaFraction1( a, b, x );\n\t\telse\n\t                  w = incompleteBetaFraction2( a, b, x ) \/ xc;\n\n\t\t\/* Multiply w by the factor\n\t\t   a      b   _             _     _\n\t\t  x  (1-x)   | (a+b) \/ ( a | (a) | (b) ) .   *\/\n\n\t\ty = a * Math.log(x);\n\t\tt = b * Math.log(xc);\n\t\tif( (a+b) < MAXGAM && Math.abs(y) < MAXLOG && Math.abs(t) < MAXLOG ) {\n\t        t = Math.pow(xc,b);\n\t        t *= Math.pow(x,a);\n\t        t \/= a;\n\t        t *= w;\n\t        t *= gamma(a+b) \/ (gamma(a) * gamma(b));\n\t\t\tif( flag ) {\n \t           if( t <= MACHEP ) \tt = 1.0 - MACHEP;\n\t           else  \t\t        t = 1.0 - t;\n\t        }\n\t\t\treturn t;\n\t    }\n\t\t\/* Resort to logarithms.  *\/\n\t\ty += t + logGamma(a+b) - logGamma(a) - logGamma(b);\n\t\ty += Math.log(w\/a);\n\t\tif( y < MINLOG )\n\t                    t = 0.0;\n\t\telse\n\t                    t = Math.exp(y);\n\n\t\tif( flag ) {\n \t           if( t <= MACHEP ) \tt = 1.0 - MACHEP;\n\t           else  \t\t        t = 1.0 - t;\n\t    }\n\t\treturn t;\n   }   \n\/**\n * Continued fraction expansion #1 for incomplete beta integral; formerly named <tt>incbcf<\/tt>.\n *\/\nstatic double incompleteBetaFraction1( double a, double b, double x ) throws ArithmeticException {\n\t   double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;\n\t   double k1, k2, k3, k4, k5, k6, k7, k8;\n\t   double r, t, ans, thresh;\n\t   int n;\n\n\t   k1 = a;\n\t   k2 = a + b;\n\t   k3 = a;\n\t   k4 = a + 1.0;\n\t   k5 = 1.0;\n\t   k6 = b - 1.0;\n\t   k7 = k4;\n\t   k8 = a + 2.0;\n\n\t   pkm2 = 0.0;\n\t   qkm2 = 1.0;\n\t   pkm1 = 1.0;\n\t   qkm1 = 1.0;\n\t   ans = 1.0;\n\t   r = 1.0;\n\t   n = 0;\n\t   thresh = 3.0 * MACHEP;\n\t   do {\n\t      xk = -( x * k1 * k2 )\/( k3 * k4 );\n\t      pk = pkm1 +  pkm2 * xk;\n\t      qk = qkm1 +  qkm2 * xk;\n\t      pkm2 = pkm1;\n\t      pkm1 = pk;\n\t      qkm2 = qkm1;\n\t      qkm1 = qk;\n\n\t      xk = ( x * k5 * k6 )\/( k7 * k8 );\n\t      pk = pkm1 +  pkm2 * xk;\n\t      qk = qkm1 +  qkm2 * xk;\n\t      pkm2 = pkm1;\n\t      pkm1 = pk;\n\t      qkm2 = qkm1;\n\t      qkm1 = qk;\n\n\t      if( qk != 0 )\t\tr = pk\/qk;\n\t      if( r != 0 ) {\n\t\t       t = Math.abs( (ans - r)\/r );\n\t\t       ans = r;\n\t\t  }\telse\n\t\t       t = 1.0;\n\n\t      if( t < thresh ) return ans;\n\n\t      k1 += 1.0;\n\t\t  k2 += 1.0;\n\t  \t  k3 += 2.0;\n\t  \t  k4 += 2.0;\n\t  \t  k5 += 1.0;\n\t  \t  k6 -= 1.0;\n\t  \t  k7 += 2.0;\n\t  \t  k8 += 2.0;\n\n\t  \t  if( (Math.abs(qk) + Math.abs(pk)) > big ) {\n\t  \t\tpkm2 *= biginv;\n\t  \t\tpkm1 *= biginv;\n\t  \t\tqkm2 *= biginv;\n\t  \t\tqkm1 *= biginv;\n\t\t  }\n\t  \t  if( (Math.abs(qk) < biginv) || (Math.abs(pk) < biginv) ) {\n\t  \t\tpkm2 *= big;\n\t  \t\tpkm1 *= big;\n\t  \t\tqkm2 *= big;\n\t  \t\tqkm1 *= big;\n\t\t  }\n\t   } while( ++n < 300 );\n\n\treturn ans;\n   }   \n\/**\n * Continued fraction expansion #2 for incomplete beta integral; formerly named <tt>incbd<\/tt>.\n *\/\nstatic double incompleteBetaFraction2( double a, double b, double x ) throws ArithmeticException {\n\t\t double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;\n\t\t double k1, k2, k3, k4, k5, k6, k7, k8;\n\t\t double r, t, ans, z, thresh;\n\t\t int n;\n\n\t\t k1 = a;\n\t\t k2 = b - 1.0;\n\t\t k3 = a;\n\t\t k4 = a + 1.0;\n\t\t k5 = 1.0;\n\t\t k6 = a + b;\n\t\t k7 = a + 1.0;;\n\t\t k8 = a + 2.0;\n\n\t\t pkm2 = 0.0;\n\t\t qkm2 = 1.0;\n\t\t pkm1 = 1.0;\n\t\t qkm1 = 1.0;\n\t\t z = x \/ (1.0-x);\n\t\t ans = 1.0;\n\t\t r = 1.0;\n\t\t n = 0;\n\t\t thresh = 3.0 * MACHEP;\n\t\t do {\n\t         xk = -( z * k1 * k2 )\/( k3 * k4 );\n\t         pk = pkm1 +  pkm2 * xk;\n\t         qk = qkm1 +  qkm2 * xk;\n\t         pkm2 = pkm1;\n\t         pkm1 = pk;\n\t         qkm2 = qkm1;\n\t         qkm1 = qk;\n\n\t         xk = ( z * k5 * k6 )\/( k7 * k8 );\n\t         pk = pkm1 +  pkm2 * xk;\n\t         qk = qkm1 +  qkm2 * xk;\n\t         pkm2 = pkm1;\n\t         pkm1 = pk;\n\t         qkm2 = qkm1;\n\t         qkm1 = qk;\n\n\t         if( qk != 0 )  r = pk\/qk;\n\t         if( r != 0 ) {\n\t\t         t = Math.abs( (ans - r)\/r );\n\t\t         ans = r;\n\t\t     } else\n\t\t         t = 1.0;\n\n\t         if( t < thresh ) return ans;\n\n\t         k1 += 1.0;\n\t         k2 -= 1.0;\n\t         k3 += 2.0;\n\t         k4 += 2.0;\n\t         k5 += 1.0;\n\t         k6 += 1.0;\n\t         k7 += 2.0;\n\t         k8 += 2.0;\n\n\t         if( (Math.abs(qk) + Math.abs(pk)) > big ) {\n\t\t        pkm2 *= biginv;\n\t\t        pkm1 *= biginv;\n\t\t        qkm2 *= biginv;\n\t\t        qkm1 *= biginv;\n\t\t     }\n\t         if( (Math.abs(qk) < biginv) || (Math.abs(pk) < biginv) ) {\n\t\t        pkm2 *= big;\n\t\t        pkm1 *= big;\n\t\t        qkm2 *= big;\n\t\t        qkm1 *= big;\n\t\t     }\n\t    } while( ++n < 300 );\n\n\t\treturn ans;\n\t }\n","comment-text":"Returns the Incomplete Beta Function evaluated from zero to <tt>xx<\/tt>; formerly named <tt>ibeta<\/tt>.","line-end":389,"lines":{"153":"public static double incompleteBeta( double aa, double bb, double xx ) throws ArithmeticException {","154":"\t\tdouble a, b, t, x, xc, w, y;","155":"\t\tboolean flag;","156":"","157":"\t\tif( aa <= 0.0 || bb <= 0.0 ) throw new ","158":"\t\t\t\t\t\t  ArithmeticException(\"ibeta: Domain error!\");","159":"","171":"","170":"\t    }","169":"\t\t    return t;","168":"\t        t = powerSeries(aa, bb, xx);","175":"\t\tif( xx > (aa\/(aa+bb)) ) {","174":"\t\t\/* Reverse a and b if x is greater than the mean. *\/","173":"","172":"\t\tw = 1.0 - xx;","163":"\t\t   throw new ArithmeticException(\"ibeta: Domain error!\");","162":"   \t       if( xx == 1.0 ) return 1.0;","161":"  \t       if( xx == 0.0 ) return 0.0;","160":"\t\tif( (xx <= 0.0) || ( xx >= 1.0) ) {","167":"\t\tif( (bb * xx) <= 1.0 && xx <= 0.95) {","166":"\t\tflag = false;","165":"","164":"\t    }","186":"\t    }","187":"","184":"\t       xc = w;","185":"\t       x = xx;","190":"\t       if( t <= MACHEP ) \tt = 1.0 - MACHEP;","191":"\t       else  \t\t        t = 1.0 - t;","188":"\t\tif( flag  && (b * x) <= 1.0 && x <= 0.95) {","189":" \t       t = powerSeries(a, b, x);","178":"\t       b = aa;","179":"\t       xc = xx;","176":"\t       flag = true;","177":"\t       a = bb;","182":"  \t       a = aa;","183":"\t       b = bb;","180":"\t       x = w;","181":"\t    } else {","205":"","204":"\t\t  x  (1-x)   | (a+b) \/ ( a | (a) | (b) ) .   *\/","207":"\t\tt = b * Math.log(xc);","206":"\t\ty = a * Math.log(x);","201":"","200":"\t                  w = incompleteBetaFraction2( a, b, x ) \/ xc;","203":"\t\t   a      b   _             _     _","202":"\t\t\/* Multiply w by the factor","197":"\t\tif( y < 0.0 )","196":"\t\ty = x * (a+b-2.0) - (a-1.0);","199":"\t\telse","198":"\t                  w = incompleteBetaFraction1( a, b, x );","193":"\t    }","192":"\t\t   return t;","195":"\t\t\/* Choose expansion for better convergence. *\/","194":"","220":"\t\t\/* Resort to logarithms.  *\/","221":"\t\ty += t + logGamma(a+b) - logGamma(a) - logGamma(b);","222":"\t\ty += Math.log(w\/a);","223":"\t\tif( y < MINLOG )","216":"\t           else  \t\t        t = 1.0 - t;","217":"\t        }","218":"\t\t\treturn t;","219":"\t    }","212":"\t        t *= w;","213":"\t        t *= gamma(a+b) \/ (gamma(a) * gamma(b));","214":"\t\t\tif( flag ) {","215":" \t           if( t <= MACHEP ) \tt = 1.0 - MACHEP;","208":"\t\tif( (a+b) < MAXGAM && Math.abs(y) < MAXLOG && Math.abs(t) < MAXLOG ) {","209":"\t        t = Math.pow(xc,b);","210":"\t        t *= Math.pow(x,a);","211":"\t        t \/= a;","239":"\t   double k1, k2, k3, k4, k5, k6, k7, k8;","238":"\t   double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;","237":"static double incompleteBetaFraction1( double a, double b, double x ) throws ArithmeticException {","236":" *\/","235":" * Continued fraction expansion #1 for incomplete beta integral; formerly named <tt>incbcf<\/tt>.","234":"\/**","233":"   }   ","232":"\t\treturn t;","231":"\t    }","230":"\t           else  \t\t        t = 1.0 - t;","229":" \t           if( t <= MACHEP ) \tt = 1.0 - MACHEP;","228":"\t\tif( flag ) {","227":"","226":"\t                    t = Math.exp(y);","225":"\t\telse","224":"\t                    t = 0.0;","254":"\t   pkm1 = 1.0;","255":"\t   qkm1 = 1.0;","252":"\t   pkm2 = 0.0;","253":"\t   qkm2 = 1.0;","250":"\t   k8 = a + 2.0;","251":"","248":"\t   k6 = b - 1.0;","249":"\t   k7 = k4;","246":"\t   k4 = a + 1.0;","247":"\t   k5 = 1.0;","244":"\t   k2 = a + b;","245":"\t   k3 = a;","242":"","243":"\t   k1 = a;","240":"\t   double r, t, ans, thresh;","241":"\t   int n;","275":"\t      qkm1 = qk;","274":"\t      qkm2 = qkm1;","273":"\t      pkm1 = pk;","272":"\t      pkm2 = pkm1;","279":"\t\t       t = Math.abs( (ans - r)\/r );","278":"\t      if( r != 0 ) {","277":"\t      if( qk != 0 )\t\tr = pk\/qk;","276":"","283":"","282":"\t\t       t = 1.0;","281":"\t\t  }\telse","280":"\t\t       ans = r;","287":"\t\t  k2 += 1.0;","286":"\t      k1 += 1.0;","285":"","284":"\t      if( t < thresh ) return ans;","258":"\t   n = 0;","259":"\t   thresh = 3.0 * MACHEP;","256":"\t   ans = 1.0;","257":"\t   r = 1.0;","262":"\t      pk = pkm1 +  pkm2 * xk;","263":"\t      qk = qkm1 +  qkm2 * xk;","260":"\t   do {","261":"\t      xk = -( x * k1 * k2 )\/( k3 * k4 );","266":"\t      qkm2 = qkm1;","267":"\t      qkm1 = qk;","264":"\t      pkm2 = pkm1;","265":"\t      pkm1 = pk;","270":"\t      pk = pkm1 +  pkm2 * xk;","271":"\t      qk = qkm1 +  qkm2 * xk;","268":"","269":"\t      xk = ( x * k5 * k6 )\/( k7 * k8 );","305":"\t  \t\tqkm1 *= big;","304":"\t  \t\tqkm2 *= big;","307":"\t   } while( ++n < 300 );","306":"\t\t  }","309":"\treturn ans;","308":"","311":"\/**","310":"   }   ","313":" *\/","312":" * Continued fraction expansion #2 for incomplete beta integral; formerly named <tt>incbd<\/tt>.","315":"\t\t double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;","314":"static double incompleteBetaFraction2( double a, double b, double x ) throws ArithmeticException {","317":"\t\t double r, t, ans, z, thresh;","316":"\t\t double k1, k2, k3, k4, k5, k6, k7, k8;","319":"","318":"\t\t int n;","288":"\t  \t  k3 += 2.0;","289":"\t  \t  k4 += 2.0;","290":"\t  \t  k5 += 1.0;","291":"\t  \t  k6 -= 1.0;","292":"\t  \t  k7 += 2.0;","293":"\t  \t  k8 += 2.0;","294":"","295":"\t  \t  if( (Math.abs(qk) + Math.abs(pk)) > big ) {","296":"\t  \t\tpkm2 *= biginv;","297":"\t  \t\tpkm1 *= biginv;","298":"\t  \t\tqkm2 *= biginv;","299":"\t  \t\tqkm1 *= biginv;","300":"\t\t  }","301":"\t  \t  if( (Math.abs(qk) < biginv) || (Math.abs(pk) < biginv) ) {","302":"\t  \t\tpkm2 *= big;","303":"\t  \t\tpkm1 *= big;","343":"\t         pkm1 = pk;","342":"\t         pkm2 = pkm1;","341":"\t         qk = qkm1 +  qkm2 * xk;","340":"\t         pk = pkm1 +  pkm2 * xk;","339":"\t         xk = -( z * k1 * k2 )\/( k3 * k4 );","338":"\t\t do {","337":"\t\t thresh = 3.0 * MACHEP;","336":"\t\t n = 0;","351":"\t         pkm1 = pk;","350":"\t         pkm2 = pkm1;","349":"\t         qk = qkm1 +  qkm2 * xk;","348":"\t         pk = pkm1 +  pkm2 * xk;","347":"\t         xk = ( z * k5 * k6 )\/( k7 * k8 );","346":"","345":"\t         qkm1 = qk;","344":"\t         qkm2 = qkm1;","326":"\t\t k7 = a + 1.0;;","327":"\t\t k8 = a + 2.0;","324":"\t\t k5 = 1.0;","325":"\t\t k6 = a + b;","322":"\t\t k3 = a;","323":"\t\t k4 = a + 1.0;","320":"\t\t k1 = a;","321":"\t\t k2 = b - 1.0;","334":"\t\t ans = 1.0;","335":"\t\t r = 1.0;","332":"\t\t qkm1 = 1.0;","333":"\t\t z = x \/ (1.0-x);","330":"\t\t qkm2 = 1.0;","331":"\t\t pkm1 = 1.0;","328":"","329":"\t\t pkm2 = 0.0;","373":"\t         if( (Math.abs(qk) + Math.abs(pk)) > big ) {","372":"","375":"\t\t        pkm1 *= biginv;","374":"\t\t        pkm2 *= biginv;","369":"\t         k6 += 1.0;","368":"\t         k5 += 1.0;","371":"\t         k8 += 2.0;","370":"\t         k7 += 2.0;","381":"\t\t        pkm1 *= big;","380":"\t\t        pkm2 *= big;","383":"\t\t        qkm1 *= big;","382":"\t\t        qkm2 *= big;","377":"\t\t        qkm1 *= biginv;","376":"\t\t        qkm2 *= biginv;","379":"\t         if( (Math.abs(qk) < biginv) || (Math.abs(pk) < biginv) ) {","378":"\t\t     }","356":"\t         if( r != 0 ) {","357":"\t\t         t = Math.abs( (ans - r)\/r );","358":"\t\t         ans = r;","359":"\t\t     } else","352":"\t         qkm2 = qkm1;","353":"\t         qkm1 = qk;","354":"","355":"\t         if( qk != 0 )  r = pk\/qk;","364":"\t         k1 += 1.0;","365":"\t         k2 -= 1.0;","366":"\t         k3 += 2.0;","367":"\t         k4 += 2.0;","360":"\t\t         t = 1.0;","361":"","362":"\t         if( t < thresh ) return ans;","363":"","387":"\t\treturn ans;","386":"","385":"\t    } while( ++n < 300 );","384":"\t\t     }","388":"\t }"},"return-type":"double","qualified-name":"cern.jet.stat.Gamma.incompleteBeta","modifiers":"public static","flat-signature":"(double, double, double)","line-start":153,"signature":"(double, double, double)","raw-comment-text":" Returns the Incomplete Beta Function evaluated from zero to <tt>xx<\/tt>; formerly named <tt>ibeta<\/tt>.\n\n @param aa the alpha parameter of the beta distribution.\n @param bb the beta parameter of the beta distribution.\n @param xx the integration end point.\n"},"beta":{"tags":{},"source":"static public double beta(double a, double b) throws ArithmeticException {\n\tdouble y;\n\t\n\ty = a + b;\n\ty = gamma(y);\n\tif( y == 0.0 ) return 1.0;\n\n\tif( a > b ) {\n\t\ty = gamma(a)\/y;\n\t\ty *= gamma(b);\n\t}\n\telse {\n\t\ty = gamma(b)\/y;\n\t\ty *= gamma(a);\n\t}\n\n\treturn(y);\n}\n","comment-text":"Returns the beta function of the arguments.\n <pre>\n                   -     -\n                  | (a) | (b)\n beta( a, b )  =  -----------.\n                     -\n                    | (a+b)\n <\/pre>","line-end":57,"lines":{"39":"static public double beta(double a, double b) throws ArithmeticException {","42":"\ty = a + b;","43":"\ty = gamma(y);","40":"\tdouble y;","41":"\t","46":"\tif( a > b ) {","47":"\t\ty = gamma(a)\/y;","44":"\tif( y == 0.0 ) return 1.0;","45":"","51":"\t\ty = gamma(b)\/y;","50":"\telse {","49":"\t}","48":"\t\ty *= gamma(b);","55":"\treturn(y);","54":"","53":"\t}","52":"\t\ty *= gamma(a);","56":"}"},"return-type":"double","qualified-name":"cern.jet.stat.Gamma.beta","modifiers":"public static","flat-signature":"(double, double)","line-start":39,"signature":"(double, double)","raw-comment-text":" Returns the beta function of the arguments.\n <pre>\n                   -     -\n                  | (a) | (b)\n beta( a, b )  =  -----------.\n                     -\n                    | (a+b)\n <\/pre>\n"},"incompleteGammaComplement":{"tags":{"@param":{"text":"x the integration start point.","kind":"@param"}},"source":"static public double incompleteGammaComplement( double a, double x ) throws ArithmeticException {\n\t\tdouble ans, ax, c, yc, r, t, y, z;\n\t\tdouble pk, pkm1, pkm2, qk, qkm1, qkm2;\n\n\t\tif( x <= 0 || a <= 0 ) return 1.0;\n\n\t\tif( x < 1.0 || x < a ) return 1.0 - incompleteGamma(a,x);\n\n\t\tax = a * Math.log(x) - x - logGamma(a);\n\t\tif( ax < -MAXLOG ) return 0.0;\n\n\t\tax = Math.exp(ax);\n\n\t\t\/* continued fraction *\/\n\t\ty = 1.0 - a;\n\t\tz = x + y + 1.0;\n\t\tc = 0.0;\n\t\tpkm2 = 1.0;\n\t\tqkm2 = x;\n\t\tpkm1 = x + 1.0;\n\t\tqkm1 = z * x;\n\t\tans = pkm1\/qkm1;\n\n\t\tdo {\n  \t    c += 1.0;\n\t    y += 1.0;\n\t    z += 2.0;\n\t    yc = y * c;\n\t    pk = pkm1 * z  -  pkm2 * yc;\n\t    qk = qkm1 * z  -  qkm2 * yc;\n\t    if( qk != 0 ) {\n\t\tr = pk\/qk;\n\t\tt = Math.abs( (ans - r)\/r );\n\t\tans = r;\n\t    } else\n\t\tt = 1.0;\n\n\t    pkm2 = pkm1;\n\t    pkm1 = pk;\n\t    qkm2 = qkm1;\n\t    qkm1 = qk;\n\t    if( Math.abs(pk) > big ) {\n\t\tpkm2 *= biginv;\n\t\tpkm1 *= biginv;\n\t\tqkm2 *= biginv;\n\t\tqkm1 *= biginv;\n\t    }\n\t} while( t > MACHEP );\n\n\t\treturn ans * ax;\n\t }\n","comment-text":"Returns the Complemented Incomplete Gamma function; formerly named <tt>igamc<\/tt>.","line-end":481,"lines":{"440":"","441":"\t\tax = Math.exp(ax);","442":"","443":"\t\t\/* continued fraction *\/","444":"\t\ty = 1.0 - a;","445":"\t\tz = x + y + 1.0;","446":"\t\tc = 0.0;","447":"\t\tpkm2 = 1.0;","432":"\t\tdouble pk, pkm1, pkm2, qk, qkm1, qkm2;","433":"","434":"\t\tif( x <= 0 || a <= 0 ) return 1.0;","435":"","436":"\t\tif( x < 1.0 || x < a ) return 1.0 - incompleteGamma(a,x);","437":"","438":"\t\tax = a * Math.log(x) - x - logGamma(a);","439":"\t\tif( ax < -MAXLOG ) return 0.0;","431":"\t\tdouble ans, ax, c, yc, r, t, y, z;","430":"static public double incompleteGammaComplement( double a, double x ) throws ArithmeticException {","478":"","479":"\t\treturn ans * ax;","476":"\t    }","477":"\t} while( t > MACHEP );","474":"\t\tqkm2 *= biginv;","475":"\t\tqkm1 *= biginv;","472":"\t\tpkm2 *= biginv;","473":"\t\tpkm1 *= biginv;","470":"\t    qkm1 = qk;","471":"\t    if( Math.abs(pk) > big ) {","468":"\t    pkm1 = pk;","469":"\t    qkm2 = qkm1;","466":"","467":"\t    pkm2 = pkm1;","464":"\t    } else","465":"\t\tt = 1.0;","463":"\t\tans = r;","462":"\t\tt = Math.abs( (ans - r)\/r );","461":"\t\tr = pk\/qk;","460":"\t    if( qk != 0 ) {","459":"\t    qk = qkm1 * z  -  qkm2 * yc;","458":"\t    pk = pkm1 * z  -  pkm2 * yc;","457":"\t    yc = y * c;","456":"\t    z += 2.0;","455":"\t    y += 1.0;","454":"  \t    c += 1.0;","453":"\t\tdo {","452":"","451":"\t\tans = pkm1\/qkm1;","450":"\t\tqkm1 = z * x;","449":"\t\tpkm1 = x + 1.0;","448":"\t\tqkm2 = x;","480":"\t }"},"return-type":"double","qualified-name":"cern.jet.stat.Gamma.incompleteGammaComplement","modifiers":"public static","flat-signature":"(double, double)","line-start":430,"signature":"(double, double)","raw-comment-text":" Returns the Complemented Incomplete Gamma function; formerly named <tt>igamc<\/tt>.\n @param a the parameter of the gamma distribution.\n @param x the integration start point.\n"}},"tags":{"@author":{"text":"wolfgang.hoschek@cern.ch","kind":"@author"},"@version":{"text":"0.9, 22-Jun-99","kind":"@version"}},"superclass":"cern.jet.math.Constants","comment-text":"Gamma and Beta functions.\n <p>\n <b>Implementation:<\/b>\n <dt>\n Some code taken and adapted from the <A HREF=\"http:\/\/www.sci.usq.edu.au\/staff\/leighb\/graph\/Top.html\">Java 2D Graph Package 2.4<\/A>,\n which in turn is a port from the <A HREF=\"http:\/\/people.ne.mediaone.net\/moshier\/index.html#Cephes\">Cephes 2.2<\/A> Math Library (C).\n Most Cephes code (missing from the 2D Graph Package) directly ported.","package":"cern.jet.stat","source-file":"stat\/Gamma.java","qualified-name":"cern.jet.stat.Gamma","line-start":24,"fields":{}}},"comment-text":""},"cern.jet.random":{"classes":{"Gamma":{"methods":{"nextDouble":{"tags":{},"source":"public double nextDouble(double alpha, double lambda) {\n\/******************************************************************\n *                                                                *\n *    Gamma Distribution - Acceptance Rejection combined with     *\n *                         Acceptance Complement                  *\n *                                                                *\n ******************************************************************\n *                                                                *\n * FUNCTION:    - gds samples a random number from the standard   *\n *                gamma distribution with parameter  a > 0.       *\n *                Acceptance Rejection  gs  for  a < 1 ,          *\n *                Acceptance Complement gd  for  a >= 1 .         *\n * REFERENCES:  - J.H. Ahrens, U. Dieter (1974): Computer methods *\n *                for sampling from gamma, beta, Poisson and      *\n *                binomial distributions, Computing 12, 223-246.  *\n *              - J.H. Ahrens, U. Dieter (1982): Generating gamma *\n *                variates by a modified rejection technique,     *\n *                Communications of the ACM 25, 47-54.            *\n * SUBPROGRAMS: - drand(seed) ... (0,1)-Uniform generator with    *\n *                unsigned long integer *seed                     *\n *              - NORMAL(seed) ... Normal generator N(0,1).       *\n *                                                                *\n ******************************************************************\/\n \tdouble a = alpha;\n\tdouble aa = -1.0, aaa = -1.0, \n\t\tb=0.0, c=0.0, d=0.0, e, r, s=0.0, si=0.0, ss=0.0, q0=0.0,\n\t\tq1 = 0.0416666664, q2 =  0.0208333723, q3 = 0.0079849875,\n\t\tq4 = 0.0015746717, q5 = -0.0003349403, q6 = 0.0003340332,\n\t\tq7 = 0.0006053049, q8 = -0.0004701849, q9 = 0.0001710320,\n\t\ta1 = 0.333333333,  a2 = -0.249999949,  a3 = 0.199999867,\n\t\ta4 =-0.166677482,  a5 =  0.142873973,  a6 =-0.124385581,\n\t\ta7 = 0.110368310,  a8 = -0.112750886,  a9 = 0.104089866,\n\t\te1 = 1.000000000,  e2 =  0.499999994,  e3 = 0.166666848,\n\t\te4 = 0.041664508,  e5 =  0.008345522,  e6 = 0.001353826,\n\t\te7 = 0.000247453;\n\n\tdouble gds,p,q,t,sign_u,u,v,w,x;\n\tdouble v1,v2,v12;\n\n\t\/\/ Check for invalid input values\n\n\tif (a <= 0.0) throw new IllegalArgumentException(); \n\tif (lambda <= 0.0) new IllegalArgumentException(); \n\n\tif (a < 1.0) { \/\/ CASE A: Acceptance rejection algorithm gs\n\t\tb = 1.0 + 0.36788794412 * a;              \/\/ Step 1\n\t\tfor(;;) {\n\t\t\tp = b * randomGenerator.raw();\n\t\t\tif (p <= 1.0) {                       \/\/ Step 2. Case gds <= 1\n\t\t\t\tgds = Math.exp(Math.log(p) \/ a);\n\t\t\t\tif (Math.log(randomGenerator.raw()) <= -gds) return(gds\/lambda);\n\t\t\t}\n\t\t\telse {                                \/\/ Step 3. Case gds > 1\n\t\t\t\tgds = - Math.log ((b - p) \/ a);\n\t\t\t\tif (Math.log(randomGenerator.raw()) <= ((a - 1.0) * Math.log(gds))) return(gds\/lambda);\n\t\t\t}\n\t\t}\n\t}\n\n\telse {        \/\/ CASE B: Acceptance complement algorithm gd (gaussian distribution, box muller transformation)\n\t\tif (a != aa) {                        \/\/ Step 1. Preparations\n\t\t\taa = a;\n\t\t\tss = a - 0.5;\n\t\t\ts = Math.sqrt(ss);\n\t\t\td = 5.656854249 - 12.0 * s;\n\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t  \/\/ Step 2. Normal deviate\n\t\tdo {\n\t\t\tv1 = 2.0 * randomGenerator.raw() - 1.0;\n\t\t\tv2 = 2.0 * randomGenerator.raw() - 1.0;\n\t\t\tv12 = v1*v1 + v2*v2;\n\t\t} while ( v12 > 1.0 );\n\t\tt = v1*Math.sqrt(-2.0*Math.log(v12)\/v12);\n\t\tx = s + 0.5 * t;\n\t\tgds = x * x;\n\t\tif (t >= 0.0) return(gds\/lambda);         \/\/ Immediate acceptance\n\n\t\tu = randomGenerator.raw();                \/\/ Step 3. Uniform random number\n\t\tif (d * u <= t * t * t) return(gds\/lambda); \/\/ Squeeze acceptance\n\n\t\tif (a != aaa) {                           \/\/ Step 4. Set-up for hat case\n\t\t\taaa = a;\n\t\t\tr = 1.0 \/ a;\n\t\t\tq0 = ((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) *\n\t\t\t\t\t  r + q3) * r + q2) * r + q1) * r;\n\t\t\tif (a > 3.686) {\n\t\t\t\tif (a > 13.022) {\n\t\t\t\t\tb = 1.77;\n\t\t\t\t\tsi = 0.75;\n\t\t\t\t\tc = 0.1515 \/ s;\n\t\t\t\t}\n\t\t\t    else {\n\t\t\t\t\tb = 1.654 + 0.0076 * ss;\n\t\t\t\t\tsi = 1.68 \/ s + 0.275;\n\t\t\t\t\tc = 0.062 \/ s + 0.024;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb = 0.463 + s - 0.178 * ss;\n\t\t\t\tsi = 1.235;\n\t\t\t\tc = 0.195 \/ s - 0.079 + 0.016 * s;\n\t\t\t}\n\t\t}\n\t\tif (x > 0.0) {                        \/\/ Step 5. Calculation of q\n\t\t\tv = t \/ (s + s);                  \/\/ Step 6.\n\t\t\tif (Math.abs(v) > 0.25) {\n\t\t\t\tq = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tq = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) *\n\t\t\t\t    v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;\n\t\t\t}\t\t\t\t\t\t\t\t  \/\/ Step 7. Quotient acceptance\n\t\t\tif (Math.log(1.0 - u) <= q) return(gds\/lambda);\n\t\t}\n\n\t\tfor(;;) {              \t\t\t      \/\/ Step 8. Double exponential deviate t\n\t\t\tdo {\n\t\t\t\te = -Math.log(randomGenerator.raw());\n\t\t\t\tu = randomGenerator.raw();\n\t\t\t\tu = u + u - 1.0;\n\t\t\t\tsign_u = (u > 0)? 1.0 : -1.0;\n\t\t\t\tt = b + (e * si) * sign_u;\n\t\t\t} while (t <= -0.71874483771719); \/\/ Step 9. Rejection of t\n\t\t\tv = t \/ (s + s);                  \/\/ Step 10. New q(t)\n\t\t\tif (Math.abs(v) > 0.25) {\n\t\t\t\tq = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tq = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) *\n\t\t\t\t    v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;\n\t\t\t}\n\t\t\tif (q <= 0.0) continue;           \/\/ Step 11.\n\t\t\tif (q > 0.5) {\n\t\t\t\tw = Math.exp(q) - 1.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tw = ((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) *\n\t\t\t\t\t     q + e1) * q;\n\t\t\t}                    \t\t\t  \/\/ Step 12. Hat acceptance\n\t\t\tif ( c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {\n\t\t\t\tx = s + 0.5 * t;\n\t\t\t\treturn(x*x\/lambda);\n\t\t\t}\n\t\t}\n\t}\n}\n","comment-text":"Returns a random number from the distribution; bypasses the internal state.","line-end":226,"lines":{"85":" *                                                                *","84":" *                         Acceptance Complement                  *","87":" *                                                                *","86":" ******************************************************************","81":"\/******************************************************************","80":"public double nextDouble(double alpha, double lambda) {","83":" *    Gamma Distribution - Acceptance Rejection combined with     *","82":" *                                                                *","93":" *                for sampling from gamma, beta, Poisson and      *","92":" * REFERENCES:  - J.H. Ahrens, U. Dieter (1974): Computer methods *","95":" *              - J.H. Ahrens, U. Dieter (1982): Generating gamma *","94":" *                binomial distributions, Computing 12, 223-246.  *","89":" *                gamma distribution with parameter  a > 0.       *","88":" * FUNCTION:    - gds samples a random number from the standard   *","91":" *                Acceptance Complement gd  for  a >= 1 .         *","90":" *                Acceptance Rejection  gs  for  a < 1 ,          *","102":" ******************************************************************\/","103":" \tdouble a = alpha;","100":" *              - NORMAL(seed) ... Normal generator N(0,1).       *","101":" *                                                                *","98":" * SUBPROGRAMS: - drand(seed) ... (0,1)-Uniform generator with    *","99":" *                unsigned long integer *seed                     *","96":" *                variates by a modified rejection technique,     *","97":" *                Communications of the ACM 25, 47-54.            *","110":"\t\ta4 =-0.166677482,  a5 =  0.142873973,  a6 =-0.124385581,","111":"\t\ta7 = 0.110368310,  a8 = -0.112750886,  a9 = 0.104089866,","108":"\t\tq7 = 0.0006053049, q8 = -0.0004701849, q9 = 0.0001710320,","109":"\t\ta1 = 0.333333333,  a2 = -0.249999949,  a3 = 0.199999867,","106":"\t\tq1 = 0.0416666664, q2 =  0.0208333723, q3 = 0.0079849875,","107":"\t\tq4 = 0.0015746717, q5 = -0.0003349403, q6 = 0.0003340332,","104":"\tdouble aa = -1.0, aaa = -1.0, ","105":"\t\tb=0.0, c=0.0, d=0.0, e, r, s=0.0, si=0.0, ss=0.0, q0=0.0,","119":"\t\/\/ Check for invalid input values","118":"","117":"\tdouble v1,v2,v12;","116":"\tdouble gds,p,q,t,sign_u,u,v,w,x;","115":"","114":"\t\te7 = 0.000247453;","113":"\t\te4 = 0.041664508,  e5 =  0.008345522,  e6 = 0.001353826,","112":"\t\te1 = 1.000000000,  e2 =  0.499999994,  e3 = 0.166666848,","127":"\t\t\tp = b * randomGenerator.raw();","126":"\t\tfor(;;) {","125":"\t\tb = 1.0 + 0.36788794412 * a;              \/\/ Step 1","124":"\tif (a < 1.0) { \/\/ CASE A: Acceptance rejection algorithm gs","123":"","122":"\tif (lambda <= 0.0) new IllegalArgumentException(); ","121":"\tif (a <= 0.0) throw new IllegalArgumentException(); ","120":"","137":"\t}","136":"\t\t}","139":"\telse {        \/\/ CASE B: Acceptance complement algorithm gd (gaussian distribution, box muller transformation)","138":"","141":"\t\t\taa = a;","140":"\t\tif (a != aa) {                        \/\/ Step 1. Preparations","143":"\t\t\ts = Math.sqrt(ss);","142":"\t\t\tss = a - 0.5;","129":"\t\t\t\tgds = Math.exp(Math.log(p) \/ a);","128":"\t\t\tif (p <= 1.0) {                       \/\/ Step 2. Case gds <= 1","131":"\t\t\t}","130":"\t\t\t\tif (Math.log(randomGenerator.raw()) <= -gds) return(gds\/lambda);","133":"\t\t\t\tgds = - Math.log ((b - p) \/ a);","132":"\t\t\telse {                                \/\/ Step 3. Case gds > 1","135":"\t\t\t}","134":"\t\t\t\tif (Math.log(randomGenerator.raw()) <= ((a - 1.0) * Math.log(gds))) return(gds\/lambda);","152":"\t\tt = v1*Math.sqrt(-2.0*Math.log(v12)\/v12);","153":"\t\tx = s + 0.5 * t;","154":"\t\tgds = x * x;","155":"\t\tif (t >= 0.0) return(gds\/lambda);         \/\/ Immediate acceptance","156":"","157":"\t\tu = randomGenerator.raw();                \/\/ Step 3. Uniform random number","158":"\t\tif (d * u <= t * t * t) return(gds\/lambda); \/\/ Squeeze acceptance","159":"","144":"\t\t\td = 5.656854249 - 12.0 * s;","145":"\t\t}","146":"\t\t\t\t\t\t\t\t\t\t\t\t  \/\/ Step 2. Normal deviate","147":"\t\tdo {","148":"\t\t\tv1 = 2.0 * randomGenerator.raw() - 1.0;","149":"\t\t\tv2 = 2.0 * randomGenerator.raw() - 1.0;","150":"\t\t\tv12 = v1*v1 + v2*v2;","151":"\t\t} while ( v12 > 1.0 );","171":"\t\t\t    else {","170":"\t\t\t\t}","169":"\t\t\t\t\tc = 0.1515 \/ s;","168":"\t\t\t\t\tsi = 0.75;","175":"\t\t\t\t}","174":"\t\t\t\t\tc = 0.062 \/ s + 0.024;","173":"\t\t\t\t\tsi = 1.68 \/ s + 0.275;","172":"\t\t\t\t\tb = 1.654 + 0.0076 * ss;","163":"\t\t\tq0 = ((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) *","162":"\t\t\tr = 1.0 \/ a;","161":"\t\t\taaa = a;","160":"\t\tif (a != aaa) {                           \/\/ Step 4. Set-up for hat case","167":"\t\t\t\t\tb = 1.77;","166":"\t\t\t\tif (a > 13.022) {","165":"\t\t\tif (a > 3.686) {","164":"\t\t\t\t\t  r + q3) * r + q2) * r + q1) * r;","186":"\t\t\t\tq = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);","187":"\t\t\t}","184":"\t\t\tv = t \/ (s + s);                  \/\/ Step 6.","185":"\t\t\tif (Math.abs(v) > 0.25) {","190":"\t\t\t\t    v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;","191":"\t\t\t}\t\t\t\t\t\t\t\t  \/\/ Step 7. Quotient acceptance","188":"\t\t\telse {","189":"\t\t\t\tq = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) *","178":"\t\t\t\tb = 0.463 + s - 0.178 * ss;","179":"\t\t\t\tsi = 1.235;","176":"\t\t\t}","177":"\t\t\telse {","182":"\t\t}","183":"\t\tif (x > 0.0) {                        \/\/ Step 5. Calculation of q","180":"\t\t\t\tc = 0.195 \/ s - 0.079 + 0.016 * s;","181":"\t\t\t}","205":"\t\t\t\tq = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log(1.0 + v);","204":"\t\t\tif (Math.abs(v) > 0.25) {","207":"\t\t\telse {","206":"\t\t\t}","201":"\t\t\t\tt = b + (e * si) * sign_u;","200":"\t\t\t\tsign_u = (u > 0)? 1.0 : -1.0;","203":"\t\t\tv = t \/ (s + s);                  \/\/ Step 10. New q(t)","202":"\t\t\t} while (t <= -0.71874483771719); \/\/ Step 9. Rejection of t","197":"\t\t\t\te = -Math.log(randomGenerator.raw());","196":"\t\t\tdo {","199":"\t\t\t\tu = u + u - 1.0;","198":"\t\t\t\tu = randomGenerator.raw();","193":"\t\t}","192":"\t\t\tif (Math.log(1.0 - u) <= q) return(gds\/lambda);","195":"\t\tfor(;;) {              \t\t\t      \/\/ Step 8. Double exponential deviate t","194":"","220":"\t\t\t\tx = s + 0.5 * t;","221":"\t\t\t\treturn(x*x\/lambda);","222":"\t\t\t}","223":"\t\t}","216":"\t\t\t\tw = ((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) *","217":"\t\t\t\t\t     q + e1) * q;","218":"\t\t\t}                    \t\t\t  \/\/ Step 12. Hat acceptance","219":"\t\t\tif ( c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {","212":"\t\t\tif (q > 0.5) {","213":"\t\t\t\tw = Math.exp(q) - 1.0;","214":"\t\t\t}","215":"\t\t\telse {","208":"\t\t\t\tq = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) *","209":"\t\t\t\t    v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;","210":"\t\t\t}","211":"\t\t\tif (q <= 0.0) continue;           \/\/ Step 11.","225":"}","224":"\t}"},"return-type":"double","qualified-name":"cern.jet.random.Gamma.nextDouble","modifiers":"public","flat-signature":"(double, double)","line-start":80,"signature":"(double, double)","raw-comment-text":" Returns a random number from the distribution; bypasses the internal state.\n"},"pdf":{"tags":{},"source":"public double pdf(double x) {\n\tif (x < 0) throw new IllegalArgumentException();\n\tif (x == 0) {\n\t\tif (alpha == 1.0) return 1.0\/lambda;\n\t\telse return 0.0;\n\t}\n\tif (alpha == 1.0) return Math.exp(-x\/lambda)\/lambda;\n\n\treturn Math.exp((alpha-1.0) * Math.log(x\/lambda) - x\/lambda - Fun.logGamma(alpha)) \/ lambda;\n}\n","comment-text":"Returns the probability distribution function.","line-end":239,"lines":{"238":"}","237":"\treturn Math.exp((alpha-1.0) * Math.log(x\/lambda) - x\/lambda - Fun.logGamma(alpha)) \/ lambda;","236":"","235":"\tif (alpha == 1.0) return Math.exp(-x\/lambda)\/lambda;","234":"\t}","233":"\t\telse return 0.0;","232":"\t\tif (alpha == 1.0) return 1.0\/lambda;","231":"\tif (x == 0) {","230":"\tif (x < 0) throw new IllegalArgumentException();","229":"public double pdf(double x) {"},"return-type":"double","qualified-name":"cern.jet.random.Gamma.pdf","modifiers":"public","flat-signature":"(double)","line-start":229,"signature":"(double)","raw-comment-text":" Returns the probability distribution function.\n"},"toString":{"tags":{},"273":"}","272":"}","line-start":261,"source":"public String toString() {\n\treturn this.getClass().getName()+\"(\"+alpha+\",\"+lambda+\")\";\n}\n\/**\n * Sets the uniform random number generated shared by all <b>static<\/b> methods.\n * @param randomGenerator the new uniform random number generator to be shared.\n *\/\nprivate static void xstaticSetRandomGenerator(RandomEngine randomGenerator) {\n\tsynchronized (shared) {\n\t\tshared.setRandomGenerator(randomGenerator);\n\t}\n}\n}\n","262":"\treturn this.getClass().getName()+\"(\"+alpha+\",\"+lambda+\")\";","comment-text":"Returns a String representation of the receiver.","263":"}","261":"public String toString() {","266":" * @param randomGenerator the new uniform random number generator to be shared.","267":" *\/","lines":{},"return-type":"java.lang.String","264":"\/**","qualified-name":"cern.jet.random.Gamma.toString","265":" * Sets the uniform random number generated shared by all <b>static<\/b> methods.","270":"\t\tshared.setRandomGenerator(randomGenerator);","modifiers":"public","271":"\t}","flat-signature":"()","268":"private static void xstaticSetRandomGenerator(RandomEngine randomGenerator) {","raw-comment-text":" Returns a String representation of the receiver.\n","signature":"()","269":"\tsynchronized (shared) {"},"staticNextDouble":{"tags":{"@throws":{"text":"IllegalArgumentException if <tt>alpha &lt;= 0.0 || lambda &lt;= 0.0<\/tt>.","kind":"@throws"}},"source":"public static double staticNextDouble(double alpha, double lambda) {\n\tsynchronized (shared) {\n\t\treturn shared.nextDouble(alpha,lambda);\n\t}\n}\n","comment-text":"Returns a random number from the distribution.","line-end":258,"lines":{"254":"\tsynchronized (shared) {","255":"\t\treturn shared.nextDouble(alpha,lambda);","256":"\t}","257":"}","253":"public static double staticNextDouble(double alpha, double lambda) {"},"return-type":"double","qualified-name":"cern.jet.random.Gamma.staticNextDouble","modifiers":"public static","flat-signature":"(double, double)","line-start":253,"signature":"(double, double)","raw-comment-text":" Returns a random number from the distribution.\n @throws IllegalArgumentException if <tt>alpha &lt;= 0.0 || lambda &lt;= 0.0<\/tt>.\n"},"setState":{"tags":{"@throws":{"text":"IllegalArgumentException if <tt>alpha &lt;= 0.0 || lambda &lt;= 0.0<\/tt>.","kind":"@throws"}},"source":"public void setState(double alpha, double lambda) {\n\tif (alpha <= 0.0) throw new IllegalArgumentException();\n\tif (lambda <= 0.0) throw new IllegalArgumentException();\n\tthis.alpha = alpha;\n\tthis.lambda = lambda;\n}\n","comment-text":"Sets the mean and variance.","line-end":249,"lines":{"248":"}","246":"\tthis.alpha = alpha;","247":"\tthis.lambda = lambda;","244":"\tif (alpha <= 0.0) throw new IllegalArgumentException();","245":"\tif (lambda <= 0.0) throw new IllegalArgumentException();","243":"public void setState(double alpha, double lambda) {"},"return-type":"void","qualified-name":"cern.jet.random.Gamma.setState","modifiers":"public","flat-signature":"(double, double)","line-start":243,"signature":"(double, double)","raw-comment-text":" Sets the mean and variance.\n @throws IllegalArgumentException if <tt>alpha &lt;= 0.0 || lambda &lt;= 0.0<\/tt>.\n"},"cdf":{"tags":{},"source":"public double cdf(double x) {\n\treturn Probability.gamma(alpha,lambda,x);\n}\n","comment-text":"Returns the cumulative distribution function.","line-end":71,"lines":{"68":"public double cdf(double x) {","69":"\treturn Probability.gamma(alpha,lambda,x);","70":"}"},"return-type":"double","qualified-name":"cern.jet.random.Gamma.cdf","modifiers":"public","flat-signature":"(double)","line-start":68,"signature":"(double)","raw-comment-text":" Returns the cumulative distribution function.\n"}},"tags":{"@author":{"text":"wolfgang.hoschek@cern.ch","kind":"@author"},"@version":{"text":"1.0, 09\/24\/99","kind":"@version"}},"superclass":"cern.jet.random.AbstractContinousDistribution","comment-text":"Gamma distribution; <A HREF=\"http:\/\/wwwinfo.cern.ch\/asdoc\/shortwrupsdir\/g106\/top.html\"> math definition<\/A>,\n <A HREF=\"http:\/\/www.cern.ch\/RD11\/rkb\/AN16pp\/node96.html#SECTION000960000000000000000\"> definition of gamma function<\/A>\n and <A HREF=\"http:\/\/www.statsoft.com\/textbook\/glosf.html#Gamma Distribution\"> animated definition<\/A>. \n <p>\n <tt>p(x) = k * x^(alpha-1) * e^(-x\/beta)<\/tt> with <tt>k = 1\/(g(alpha) * b^a))<\/tt> and <tt>g(a)<\/tt> being the gamma function.\n <p>\n Valid parameter ranges: <tt>alpha &gt; 0<\/tt>.\n <p>\n Note: For a Gamma distribution to have the mean <tt>mean<\/tt> and variance <tt>variance<\/tt>, set the parameters as follows:\n <pre>\n alpha = mean*mean \/ variance; lambda = 1 \/ (variance \/ mean); \n <\/pre>\n <p>\n Instance methods operate on a user supplied uniform random number generator; they are unsynchronized.\n <dt>\n Static methods operate on a default uniform random number generator; they are synchronized.\n <p>\n <b>Implementation:<\/b> \n <dt>\n Method: Acceptance Rejection combined with Acceptance Complement.\n <dt>\n High performance implementation. This is a port of <A HREF=\"http:\/\/wwwinfo.cern.ch\/asd\/lhc++\/clhep\/manual\/RefGuide\/Random\/RandGamma.html\">RandGamma<\/A> used in <A HREF=\"http:\/\/wwwinfo.cern.ch\/asd\/lhc++\/clhep\">CLHEP 1.4.0<\/A> (C++).\n CLHEP's implementation, in turn, is based on <tt>gds.c<\/tt> from the <A HREF=\"http:\/\/www.cis.tu-graz.ac.at\/stat\/stadl\/random.html\">C-RAND \/ WIN-RAND<\/A> library.\n C-RAND's implementation, in turn, is based upon\n <p>\n J.H. Ahrens, U. Dieter (1974): Computer methods for sampling from gamma, beta, Poisson and binomial distributions, \n Computing 12, 223-246.\n <p>\n and\n <p>\n J.H. Ahrens, U. Dieter (1982): Generating gamma variates by a modified rejection technique,\n Communications of the ACM 25, 47-54.","package":"cern.jet.random","source-file":"math\/Gamma.java","qualified-name":"cern.jet.random.Gamma","line-start":50,"fields":{"shared":{"comment-text":"","qualified-name":"cern.jet.random.Gamma.shared","type":"cern.jet.random.Gamma"},"lambda":{"comment-text":"","qualified-name":"cern.jet.random.Gamma.lambda","type":"double"},"alpha":{"comment-text":"","qualified-name":"cern.jet.random.Gamma.alpha","type":"double"}}}},"comment-text":""}}}